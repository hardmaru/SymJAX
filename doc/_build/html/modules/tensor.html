

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>symjax.tensor &mdash; symjax 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="symjax.tensor.pdfs" href="pdfs.html" />
    <link rel="prev" title="symjax" href="symjax.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/symjax_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../user/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/examples.html">Examples</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="symjax.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.tensor</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-symjax.tensor.control_flow">Control Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-symjax.tensor.index_ops">Index Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-symjax.tensor.ops_math">Numpy Like</a></li>
<li class="toctree-l2"><a class="reference internal" href="#other">Other</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pdfs.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.tensor.pdfs</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="signal.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.tensor.signal</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="random.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.tensor.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.utils</span></code></a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="datasets.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.datasets</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="initializers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.initializers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="layers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.layers</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="optimizers.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.optimizers</span></code></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">symjax</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.tensor</span></code></li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/modules/tensor.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-symjax.tensor">
<span id="symjax-tensor"></span><h1><a class="reference internal" href="#module-symjax.tensor" title="symjax.tensor"><code class="xref py py-mod docutils literal notranslate"><span class="pre">symjax.tensor</span></code></a><a class="headerlink" href="#module-symjax.tensor" title="Permalink to this headline">¶</a></h1>
<p>Implements the NumPy API, using the primitives in <code class="xref py py-mod docutils literal notranslate"><span class="pre">jax.lax</span></code>.
As SymJAX follows the JAX restrictions, not all NumPy functins are present.</p>
<ul class="simple">
<li><p>Notably, since JAX arrays are immutable, NumPy APIs that mutate arrays
in-place cannot be implemented in JAX. However, often JAX is able to provide a
alternative API that is purely functional. For example, instead of in-place
array updates (<code class="code docutils literal notranslate"><span class="pre">x[i]</span> <span class="pre">=</span> <span class="pre">y</span></code>), JAX provides an alternative pure indexed
update function <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.ops.index_update()</span></code>.</p></li>
<li><p>NumPy is very aggressive at promoting values to <code class="code docutils literal notranslate"><span class="pre">float64</span></code> type. JAX
sometimes is less aggressive about type promotion.</p></li>
</ul>
<p>Finally, since SymJAX uses jit-compilation, any function that returns
data-dependent output shapes are incompatible and thus not implemented.
In fact, The XLA compiler requires that shapes of arrays be known at
compile time. While it would be possible to provide. Thus an implementation of an API such as <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.nonzero()</span></code>, we would be unable
to JIT-compile it because the shape of its output depends on the contents
of the input data.</p>
<p>Not every function in NumPy is implemented; contributions are welcome!</p>
<div class="section" id="module-symjax.tensor.control_flow">
<span id="control-flow"></span><h2>Control Flow<a class="headerlink" href="#module-symjax.tensor.control_flow" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="symjax.tensor.control_flow.cond">
<code class="sig-name descname">cond</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">predicate</span></em>, <em class="sig-param"><span class="n">true_predicate</span></em>, <em class="sig-param"><span class="n">true_fun</span></em>, <em class="sig-param"><span class="n">false_predicate</span></em>, <em class="sig-param"><span class="n">false_fun</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.control_flow.cond" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>predicate should be a boolean tensor with shape ()</dt><dd><p>true_input is the input passed to true_fn that will give the output
if the predicate evaluates to True, and conversely for False…</p>
</dd>
</dl>
<p>LAX-backend implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">_cond()</span></code>.
ADDITIONOriginal docstring below.</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.control_flow.scan">
<code class="sig-name descname">scan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fn</span></em>, <em class="sig-param"><span class="n">init</span></em>, <em class="sig-param"><span class="n">xs</span></em>, <em class="sig-param"><span class="n">constants</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">length</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/symjax/tensor/control_flow.html#scan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.control_flow.scan" title="Permalink to this definition">¶</a></dt>
<dd><p>Scan a function over leading array axes while carrying along state.</p>
<p>The type signature in brief is</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">scan</span> <span class="ow">::</span> <span class="p">(</span><span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span>
</pre></div>
</div>
<p>where we use [t] here to denote the type t with an additional leading axis.
That is, if t is an array type then [t] represents the type with an additional
leading axis, and if t is a pytree (container) type with array leaves then [t]
represents the type with the same pytree structure and corresponding leaves
each with an additional leading axis.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">a</span></code> is an array type or None, and <code class="docutils literal notranslate"><span class="pre">b</span></code> is an array type, the semantics
of <code class="docutils literal notranslate"><span class="pre">scan</span></code> are given roughly by this Python implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">xs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">length</span>
  <span class="n">carry</span> <span class="o">=</span> <span class="n">init</span>
  <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
    <span class="n">carry</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">carry</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Unlike that Python version, both <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> may be arbitrary pytree
types, and so multiple arrays can be scanned over at once and produce multiple
output arrays. (None is actually an empty pytree.)</p>
<p>Also unlike that Python version, <code class="docutils literal notranslate"><span class="pre">scan</span></code> is a JAX primitive and is lowered to
a single XLA While HLO. That makes it useful for reducing compilation times
for jit-compiled functions, since native Python loop constructs in an <code class="docutils literal notranslate"><span class="pre">&#64;jit</span></code>
function are unrolled, leading to large XLA computations.</p>
<p>Finally, the loop-carried value <code class="docutils literal notranslate"><span class="pre">carry</span></code> must hold a fixed shape and dtype
across all iterations (and not just be consistent up to NumPy rank/shape
broadcasting and dtype promotion rules, for example). In other words, the type
<code class="docutils literal notranslate"><span class="pre">c</span></code> in the type signature above represents an array with a fixed shape and
dtype (or a nested tuple/list/dict container data structure with a fixed
structure and arrays with fixed shape and dtype at the leaves).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> – a Python function to be scanned of type <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(c,</span> <span class="pre">b)</span></code>, meaning
that <code class="docutils literal notranslate"><span class="pre">f</span></code> accepts two arguments where the first is a value of the loop
carry and the second is a slice of <code class="docutils literal notranslate"><span class="pre">xs</span></code> along its leading axis, and that
<code class="docutils literal notranslate"><span class="pre">f</span></code> returns a pair where the first element represents a new value for
the loop carry and the second represents a slice of the output.</p></li>
<li><p><strong>init</strong> – an initial loop carry value of type <code class="docutils literal notranslate"><span class="pre">c</span></code>, which can be a scalar,
array, or any pytree (nested Python tuple/list/dict) thereof, representing
the initial loop carry value. This value must have the same structure as
the first element of the pair returned by <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p></li>
<li><p><strong>xs</strong> – the value of type <code class="docutils literal notranslate"><span class="pre">[a]</span></code> over which to scan along the leading axis,
where <code class="docutils literal notranslate"><span class="pre">[a]</span></code> can be an array or any pytree (nested Python
tuple/list/dict) thereof with consistent leading axis sizes.</p></li>
<li><p><strong>length</strong> – optional integer specifying the number of loop iterations, which
must agree with the sizes of leading axes of the arrays in <code class="docutils literal notranslate"><span class="pre">xs</span></code> (but can
be used to perform scans where no input <code class="docutils literal notranslate"><span class="pre">xs</span></code> are needed).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A pair of type <code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">[b])</span></code> where the first element represents the final
loop carry value and the second element represents the stacked outputs of
the second output of <code class="docutils literal notranslate"><span class="pre">f</span></code> when scanned over the leading axis of the inputs.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-symjax.tensor.index_ops">
<span id="index-operations"></span><h2>Index Operations<a class="headerlink" href="#module-symjax.tensor.index_ops" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="symjax.tensor.index_ops.index_update">
<code class="sig-name descname">index_update</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/ops/scatter.html#index_update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.index_ops.index_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Pure equivalent of <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">=</span> <span class="pre">y</span></code>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.index_ops.index_update" title="symjax.tensor.index_ops.index_update"><code class="xref py py-func docutils literal notranslate"><span class="pre">index_update()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>Returns the value of <cite>x</cite> that would result from the</p>
</div></blockquote>
<dl class="simple">
<dt>NumPy-style <code class="xref py py-mod docutils literal notranslate"><span class="pre">indexed</span> <span class="pre">assignment</span></code>::</dt><dd><p>x[idx] = y</p>
</dd>
</dl>
<p>Note the <cite>index_update</cite> operator is pure; <cite>x</cite> itself is
not modified, instead the new value that <cite>x</cite> would have taken is returned.</p>
<p>Unlike NumPy’s <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">=</span> <span class="pre">y</span></code>, if multiple indices refer to the same
location it is undefined which update is chosen; JAX may choose the order of
updates arbitrarily and nondeterministically (e.g., due to concurrent
updates on some hardware platforms).</p>
<dl>
<dt>Args:</dt><dd><p>x: an array with the values to be updated.
idx: a Numpy-style index, consisting of <cite>None</cite>, integers, <cite>slice</cite> objects,</p>
<blockquote>
<div><p>ellipses, ndarrays with integer dtypes, or a tuple of the above. A
convenient syntactic sugar for forming indices is via the
<code class="xref py py-data docutils literal notranslate"><span class="pre">jax.ops.index</span></code> object.</p>
</div></blockquote>
<dl class="simple">
<dt>y: the array of updates. <cite>y</cite> must be broadcastable to the shape of the</dt><dd><p>array that would be returned by <cite>x[idx]</cite>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index_update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="mf">6.</span><span class="p">)</span>
<span class="go">array([[1., 1., 1., 6., 6., 6.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 6., 6., 6.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 6., 6., 6.]], dtype=float32)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.index_ops.index_add">
<code class="sig-name descname">index_add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/ops/scatter.html#index_add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.index_ops.index_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Pure equivalent of <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">+=</span> <span class="pre">y</span></code>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.index_ops.index_add" title="symjax.tensor.index_ops.index_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">index_add()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>Returns the value of <cite>x</cite> that would result from the</p>
</div></blockquote>
<dl class="simple">
<dt>NumPy-style <code class="xref py py-mod docutils literal notranslate"><span class="pre">indexed</span> <span class="pre">assignment</span></code>::</dt><dd><p>x[idx] += y</p>
</dd>
</dl>
<p>Note the <cite>index_add</cite> operator is pure; <cite>x</cite> itself is
not modified, instead the new value that <cite>x</cite> would have taken is returned.</p>
<p>Unlike the NumPy code <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">+=</span> <span class="pre">y</span></code>, if multiple indices refer to the
same location the updates will be summed. (NumPy would only apply the last
update, rather than summing the updates.) The order in which conflicting
updates are applied is implementation-defined and may be nondeterministic
(e.g., due to concurrency on some hardware platforms).</p>
<dl>
<dt>Args:</dt><dd><p>x: an array with the values to be updated.
idx: a Numpy-style index, consisting of <cite>None</cite>, integers, <cite>slice</cite> objects,</p>
<blockquote>
<div><p>ellipses, ndarrays with integer dtypes, or a tuple of the above. A
convenient syntactic sugar for forming indices is via the
<code class="xref py py-data docutils literal notranslate"><span class="pre">jax.ops.index</span></code> object.</p>
</div></blockquote>
<dl class="simple">
<dt>y: the array of updates. <cite>y</cite> must be broadcastable to the shape of the</dt><dd><p>array that would be returned by <cite>x[idx]</cite>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="mf">6.</span><span class="p">)</span>
<span class="go">array([[1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 7., 7., 7.],</span>
<span class="go">       [1., 1., 1., 7., 7., 7.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.]], dtype=float32)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.index_ops.index_max">
<code class="sig-name descname">index_max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/ops/scatter.html#index_max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.index_ops.index_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Pure equivalent of <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">=</span> <span class="pre">maximum(x[idx],</span> <span class="pre">y)</span></code>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.index_ops.index_max" title="symjax.tensor.index_ops.index_max"><code class="xref py py-func docutils literal notranslate"><span class="pre">index_max()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>Returns the value of <cite>x</cite> that would result from the</p>
</div></blockquote>
<dl class="simple">
<dt>NumPy-style <code class="xref py py-mod docutils literal notranslate"><span class="pre">indexed</span> <span class="pre">assignment</span></code>::</dt><dd><p>x[idx] = maximum(x[idx], y)</p>
</dd>
</dl>
<p>Note the <cite>index_max</cite> operator is pure; <cite>x</cite> itself is
not modified, instead the new value that <cite>x</cite> would have taken is returned.</p>
<p>Unlike the NumPy code <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">=</span> <span class="pre">maximum(x[idx],</span> <span class="pre">y)</span></code>, if multiple indices
refer to the same location the final value will be the overall max. (NumPy
would only look at the last update, rather than all of the updates.)</p>
<dl>
<dt>Args:</dt><dd><p>x: an array with the values to be updated.
idx: a Numpy-style index, consisting of <cite>None</cite>, integers, <cite>slice</cite> objects,</p>
<blockquote>
<div><p>ellipses, ndarrays with integer dtypes, or a tuple of the above. A
convenient syntactic sugar for forming indices is via the
<code class="xref py py-data docutils literal notranslate"><span class="pre">jax.ops.index</span></code> object.</p>
</div></blockquote>
<dl class="simple">
<dt>y: the array of updates. <cite>y</cite> must be broadcastable to the shape of the</dt><dd><p>array that would be returned by <cite>x[idx]</cite>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index_max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="mf">6.</span><span class="p">)</span>
<span class="go">array([[1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 6., 6., 6.],</span>
<span class="go">       [1., 1., 1., 6., 6., 6.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.]], dtype=float32)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.index_ops.index_min">
<code class="sig-name descname">index_min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">idx</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/ops/scatter.html#index_min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.index_ops.index_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Pure equivalent of <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">=</span> <span class="pre">minimum(x[idx],</span> <span class="pre">y)</span></code>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.index_ops.index_min" title="symjax.tensor.index_ops.index_min"><code class="xref py py-func docutils literal notranslate"><span class="pre">index_min()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>Returns the value of <cite>x</cite> that would result from the</p>
</div></blockquote>
<dl class="simple">
<dt>NumPy-style <code class="xref py py-mod docutils literal notranslate"><span class="pre">indexed</span> <span class="pre">assignment</span></code>::</dt><dd><p>x[idx] = minimum(x[idx], y)</p>
</dd>
</dl>
<p>Note the <cite>index_min</cite> operator is pure; <cite>x</cite> itself is
not modified, instead the new value that <cite>x</cite> would have taken is returned.</p>
<p>Unlike the NumPy code <code class="code docutils literal notranslate"><span class="pre">x[idx]</span> <span class="pre">=</span> <span class="pre">minimum(x[idx],</span> <span class="pre">y)</span></code>, if multiple indices
refer to the same location the final value will be the overall min. (NumPy
would only look at the last update, rather than all of the updates.)</p>
<dl>
<dt>Args:</dt><dd><p>x: an array with the values to be updated.
idx: a Numpy-style index, consisting of <cite>None</cite>, integers, <cite>slice</cite> objects,</p>
<blockquote>
<div><p>ellipses, ndarrays with integer dtypes, or a tuple of the above. A
convenient syntactic sugar for forming indices is via the
<code class="xref py py-data docutils literal notranslate"><span class="pre">jax.ops.index</span></code> object.</p>
</div></blockquote>
<dl class="simple">
<dt>y: the array of updates. <cite>y</cite> must be broadcastable to the shape of the</dt><dd><p>array that would be returned by <cite>x[idx]</cite>.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>An array.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index_minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="mf">0.</span><span class="p">)</span>
<span class="go">array([[1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.],</span>
<span class="go">       [1., 1., 1., 0., 0., 0.],</span>
<span class="go">       [1., 1., 1., 0., 0., 0.],</span>
<span class="go">       [1., 1., 1., 1., 1., 1.]], dtype=float32)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-symjax.tensor.ops_math">
<span id="numpy-like"></span><h2>Numpy Like<a class="headerlink" href="#module-symjax.tensor.ops_math" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="symjax.tensor.ops_math.hat_1D">
<code class="sig-name descname">hat_1D</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">t_left</span></em>, <em class="sig-param"><span class="n">t_center</span></em>, <em class="sig-param"><span class="n">t_right</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/symjax/tensor/ops_math.html#hat_1D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.ops_math.hat_1D" title="Permalink to this definition">¶</a></dt>
<dd><p>hat basis function in 1-D</p>
<p>Hat function, continuous piecewise linear</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>array-like</em>) – the sampled input space</p></li>
<li><p><strong>t_left</strong> (<em>scalar</em>) – the position of the left knot</p></li>
<li><p><strong>t_center</strong> (<em>scalar</em>) – the position of the center knot</p></li>
<li><p><strong>t_right</strong> (<em>scalar</em>) – the position of the right knot</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>output</strong> – same shape as x with applied hat function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.ops_math.one_hot">
<code class="sig-name descname">one_hot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">'float32'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/symjax/tensor/ops_math.html#one_hot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.ops_math.one_hot" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a one-hot encoding of x of size k.</p>
</dd></dl>

</div>
<div class="section" id="other">
<h2>Other<a class="headerlink" href="#other" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="symjax.tensor.abs">
<code class="sig-name descname">abs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the absolute value element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.absolute" title="symjax.tensor.absolute"><code class="xref py py-func docutils literal notranslate"><span class="pre">absolute()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.absolute" title="symjax.tensor.absolute"><code class="xref py py-func docutils literal notranslate"><span class="pre">absolute()</span></code></a>.
Original docstring below.</p>
<p>absolute(x, /, out=None, <a href="#id1"><span class="problematic" id="id2">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p><code class="docutils literal notranslate"><span class="pre">np.abs</span></code> is a shorthand for this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>absolute</strong> – An ndarray containing the absolute value of
each element in <cite>x</cite>.  For complex input, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">ib</span></code>, the
absolute value is <span class="math notranslate nohighlight">\(\sqrt{ a^2 + b^2 }\)</span>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1.2,  1.2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.5620499351813308</span>
</pre></div>
</div>
<p>Plot the function over <code class="docutils literal notranslate"><span class="pre">[-10,</span> <span class="pre">10]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Plot the function over the complex plane:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.absolute">
<code class="sig-name descname">absolute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.absolute" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the absolute value element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.absolute" title="symjax.tensor.absolute"><code class="xref py py-func docutils literal notranslate"><span class="pre">absolute()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.absolute" title="symjax.tensor.absolute"><code class="xref py py-func docutils literal notranslate"><span class="pre">absolute()</span></code></a>.
Original docstring below.</p>
<p>absolute(x, /, out=None, <a href="#id3"><span class="problematic" id="id4">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p><code class="docutils literal notranslate"><span class="pre">np.abs</span></code> is a shorthand for this function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>absolute</strong> – An ndarray containing the absolute value of
each element in <cite>x</cite>.  For complex input, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">ib</span></code>, the
absolute value is <span class="math notranslate nohighlight">\(\sqrt{ a^2 + b^2 }\)</span>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ 1.2,  1.2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.5620499351813308</span>
</pre></div>
</div>
<p>Plot the function over <code class="docutils literal notranslate"><span class="pre">[-10,</span> <span class="pre">10]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Plot the function over the complex plane:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xx</span><span class="p">),</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add arguments element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.add" title="symjax.tensor.add"><code class="xref py py-func docutils literal notranslate"><span class="pre">add()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.add" title="symjax.tensor.add"><code class="xref py py-func docutils literal notranslate"><span class="pre">add()</span></code></a>.
Original docstring below.</p>
<p>add(x1, x2, /, out=None, <a href="#id5"><span class="problematic" id="id6">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>add</strong> – The sum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Equivalent to <cite>x1</cite> + <cite>x2</cite> in terms of array broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="go">5.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([[  0.,   2.,   4.],</span>
<span class="go">       [  3.,   5.,   7.],</span>
<span class="go">       [  6.,   8.,  10.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.all" title="symjax.tensor.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.all" title="symjax.tensor.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>all</strong> – A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray, bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.all()</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.any" title="symjax.tensor.any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></dt><dd><p>Test whether any element along a given axis evaluates to True.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">z</span>                             
<span class="go">(28293632, 28293632, array([ True]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.allclose">
<code class="sig-name descname">allclose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">rtol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">atol</span><span class="o">=</span><span class="default_value">1e-08</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#allclose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.allclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if two arrays are element-wise equal within a tolerance.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.allclose" title="symjax.tensor.allclose"><code class="xref py py-func docutils literal notranslate"><span class="pre">allclose()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.allclose" title="symjax.tensor.allclose"><code class="xref py py-func docutils literal notranslate"><span class="pre">allclose()</span></code></a>.
Original docstring below.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<p>If either array contains one or more NaNs, False is returned.
Infs are treated as equal if they are in the same place and of the same
sign in both arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>allclose</strong> – Returns True if the two arrays are equal within the given
tolerance; False otherwise.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.isclose" title="symjax.tensor.isclose"><code class="xref py py-func docutils literal notranslate"><span class="pre">isclose()</span></code></a>, <a class="reference internal" href="#symjax.tensor.all" title="symjax.tensor.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>, <a class="reference internal" href="#symjax.tensor.any" title="symjax.tensor.any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a>, <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>If the following equation is element-wise True, then allclose returns
True.</p>
<blockquote>
<div><p>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</p>
</div></blockquote>
<p>The above equation is not symmetric in <cite>a</cite> and <cite>b</cite>, so that
<code class="docutils literal notranslate"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> might be different from <code class="docutils literal notranslate"><span class="pre">allclose(b,</span> <span class="pre">a)</span></code> in
some rare cases.</p>
<p>The comparison of <cite>a</cite> and <cite>b</cite> uses standard broadcasting, which
means that <cite>a</cite> and <cite>b</cite> need not have the same shape in order for
<code class="docutils literal notranslate"><span class="pre">allclose(a,</span> <span class="pre">b)</span></code> to evaluate to True.  The same is true for
<cite>equal</cite> but not <cite>array_equal</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.alltrue">
<code class="sig-name descname">alltrue</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.alltrue" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.all" title="symjax.tensor.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.all" title="symjax.tensor.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>all</strong> – A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray, bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.all()</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.any" title="symjax.tensor.any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a></dt><dd><p>Test whether any element along a given axis evaluates to True.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]])</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span><span class="kc">False</span><span class="p">],[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">z</span>                             
<span class="go">(28293632, 28293632, array([ True]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.amax">
<code class="sig-name descname">amax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.amax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>amax</strong> – Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.argmax" title="symjax.tensor.argmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmax()</span></code></a></dt><dd><p>Return the indices of the maximum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a>, <a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.amin">
<code class="sig-name descname">amin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.amin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>amin</strong> – Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.argmin" title="symjax.tensor.argmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmin()</span></code></a></dt><dd><p>Return the indices of the minimum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a>, <a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis</span>
<span class="go">array([0, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal notranslate"><span class="pre">default</span></code> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.angle">
<code class="sig-name descname">angle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">z</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle of the complex argument.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.angle" title="symjax.tensor.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.angle" title="symjax.tensor.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>angle</strong> – The counterclockwise angle from the positive real axis on
the complex plane, with dtype as numpy.float64.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.arctan2" title="symjax.tensor.arctan2"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan2()</span></code></a>, <a class="reference internal" href="#symjax.tensor.absolute" title="symjax.tensor.absolute"><code class="xref py py-func docutils literal notranslate"><span class="pre">absolute()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">])</span>               <span class="c1"># in radians</span>
<span class="go">array([ 0.        ,  1.57079633,  0.78539816])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                  <span class="c1"># in degrees</span>
<span class="go">45.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.any" title="symjax.tensor.any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.any" title="symjax.tensor.any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a>.
Original docstring below.</p>
<p>Returns single boolean unless <cite>axis</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>any</strong> – A new boolean or <cite>ndarray</cite> is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool or ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.any()</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.all" title="symjax.tensor.all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a></dt><dd><p>Test whether all elements along a given axis evaluate to True.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate
to <cite>True</cite> because these are not equal to zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">o</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">o</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">,</span> <span class="n">o</span>
<span class="go">(array([ True]), array([ True]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check now that z is a reference to o</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="ow">is</span> <span class="n">o</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="c1"># identity of z and o              </span>
<span class="go">(191614240, 191614240)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values to the end of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.append" title="symjax.tensor.append"><code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.append" title="symjax.tensor.append"><code class="xref py py-func docutils literal notranslate"><span class="pre">append()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>append</strong> – A copy of <cite>arr</cite> with <cite>values</cite> appended to <cite>axis</cite>.  Note that
<cite>append</cite> does not occur in-place: a new array is allocated and
filled.  If <cite>axis</cite> is None, <cite>out</cite> is a flattened array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">insert()</span></code></dt><dd><p>Insert elements into an array.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">delete()</span></code></dt><dd><p>Delete elements from an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="go">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
</pre></div>
</div>
<p>When <cite>axis</cite> is specified, <cite>values</cite> must have the correct shape.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">arrays must have same number of dimensions</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arange">
<code class="sig-name descname">arange</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#arange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced values within a given interval.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arange" title="symjax.tensor.arange"><code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arange" title="symjax.tensor.arange"><code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code></a>.
Original docstring below.</p>
<p>arange([start,] stop[, step,], dtype=None)</p>
<blockquote>
<div><blockquote>
<div><p>Values are generated within the half-open interval <code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">stop)</span></code>
(in other words, the interval including <cite>start</cite> but excluding <cite>stop</cite>).
For integer arguments the function is equivalent to the Python built-in
<a class="reference external" href="http://docs.python.org/lib/built-in-funcs.html">range</a> function,
but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not
be consistent.  It is better to use <code class="docutils literal notranslate"><span class="pre">linspace</span></code> for these cases.</p>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl>
<dt>arange<span class="classifier">ndarray</span></dt><dd><p>Array of evenly spaced values.</p>
<p>For floating point arguments, the length of the result is
<code class="docutils literal notranslate"><span class="pre">ceil((stop</span> <span class="pre">-</span> <span class="pre">start)/step)</span></code>.  Because of floating point overflow,
this rule may result in the last element of <cite>out</cite> being greater
than <cite>stop</cite>.</p>
</dd>
</dl>
<p>linspace : Evenly spaced numbers with careful handling of endpoints.
ogrid: Arrays of evenly spaced numbers in N-dimensions.
mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="go">array([3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([3, 5])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arccos">
<code class="sig-name descname">arccos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arccos" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric inverse cosine, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arccos" title="symjax.tensor.arccos"><code class="xref py py-func docutils literal notranslate"><span class="pre">arccos()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arccos" title="symjax.tensor.arccos"><code class="xref py py-func docutils literal notranslate"><span class="pre">arccos()</span></code></a>.
Original docstring below.</p>
<p>arccos(x, /, out=None, <a href="#id7"><span class="problematic" id="id8">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The inverse of <cite>cos</cite> so that, if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">cos(x)</span></code>, then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">arccos(y)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>angle</strong> – The angle of the ray intersecting the unit circle at the given
<cite>x</cite>-coordinate in radians [0, pi].
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.cos" title="symjax.tensor.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">cos()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arctan" title="symjax.tensor.arctan"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arcsin" title="symjax.tensor.arcsin"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsin()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">emath.arccos()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arccos</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>cos(z) = x</cite>. The convention is to return
the angle <cite>z</cite> whose real part lies in <cite>[0, pi]</cite>.</p>
<p>For real-valued input data types, <cite>arccos</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arccos</cite> is a complex analytic function that
has branch cuts <cite>[-inf, -1]</cite> and <cite>[1, inf]</cite> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse <cite>cos</cite> is also known as <cite>acos</cite> or cos^-1.</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 79. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p class="rubric">Examples</p>
<p>We expect the arccos of 1 to be 0, and of -1 to be pi:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 0.        ,  3.14159265])</span>
</pre></div>
</div>
<p>Plot arccos:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arccosh">
<code class="sig-name descname">arccosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arccosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse hyperbolic cosine, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arccosh" title="symjax.tensor.arccosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arccosh()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arccosh" title="symjax.tensor.arccosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arccosh()</span></code></a>.
Original docstring below.</p>
<p>arccosh(x, /, out=None, <a href="#id9"><span class="problematic" id="id10">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>arccosh</strong> – Array of the same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.cosh" title="symjax.tensor.cosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">cosh()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arcsinh" title="symjax.tensor.arcsinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsinh()</span></code></a>, <a class="reference internal" href="#symjax.tensor.sinh" title="symjax.tensor.sinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinh()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arctanh" title="symjax.tensor.arctanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctanh()</span></code></a>, <a class="reference internal" href="#symjax.tensor.tanh" title="symjax.tensor.tanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tanh()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arccosh</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>cosh(z) = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite> and the real part in
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">inf]</span></code>.</p>
<p>For real-valued input data types, <cite>arccosh</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity, it
yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arccosh</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 1]</cite> and is continuous from above on it.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id11"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 86. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id12"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Inverse hyperbolic function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Arccosh">http://en.wikipedia.org/wiki/Arccosh</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="go">array([ 1.65745445,  2.99322285])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arccosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arcsin">
<code class="sig-name descname">arcsin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arcsin" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse sine, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arcsin" title="symjax.tensor.arcsin"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsin()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arcsin" title="symjax.tensor.arcsin"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsin()</span></code></a>.
Original docstring below.</p>
<p>arcsin(x, /, out=None, <a href="#id13"><span class="problematic" id="id14">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>angle</strong> – The inverse sine of each element in <cite>x</cite>, in radians and in the
closed interval <code class="docutils literal notranslate"><span class="pre">[-pi/2,</span> <span class="pre">pi/2]</span></code>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.sin" title="symjax.tensor.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">sin()</span></code></a>, <a class="reference internal" href="#symjax.tensor.cos" title="symjax.tensor.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">cos()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arccos" title="symjax.tensor.arccos"><code class="xref py py-func docutils literal notranslate"><span class="pre">arccos()</span></code></a>, <a class="reference internal" href="#symjax.tensor.tan" title="symjax.tensor.tan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tan()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arctan" title="symjax.tensor.arctan"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan()</span></code></a>, <a class="reference internal" href="#symjax.tensor.arctan2" title="symjax.tensor.arctan2"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan2()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">emath.arcsin()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arcsin</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <span class="math notranslate nohighlight">\(sin(z) = x\)</span>.  The convention is to
return the angle <cite>z</cite> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <em>arcsin</em> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arcsin</cite> is a complex analytic function that
has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
continuous from above on the former and from below on the latter.</p>
<p>The inverse sine is also known as <cite>asin</cite> or sin^{-1}.</p>
<p class="rubric">References</p>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79ff.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># pi/2</span>
<span class="go">1.5707963267948966</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># -pi/2</span>
<span class="go">-1.5707963267948966</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arcsinh">
<code class="sig-name descname">arcsinh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arcsinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse hyperbolic sine element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arcsinh" title="symjax.tensor.arcsinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsinh()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arcsinh" title="symjax.tensor.arcsinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsinh()</span></code></a>.
Original docstring below.</p>
<p>arcsinh(x, /, out=None, <a href="#id15"><span class="problematic" id="id16">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Array of the same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>arcsinh</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>sinh(z) = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi/2, pi/2]</cite>.</p>
<p>For real-valued input data types, <cite>arcsinh</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity, it
returns <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arccos</cite> is a complex analytical function that
has branch cuts <cite>[1j, infj]</cite> and <cite>[-1j, -infj]</cite> and is continuous from
the right on the former and from the left on the latter.</p>
<p>The inverse hyperbolic sine is also known as <cite>asinh</cite> or <code class="docutils literal notranslate"><span class="pre">sinh^-1</span></code>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id17"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 86. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id18"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Inverse hyperbolic function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Arcsinh">http://en.wikipedia.org/wiki/Arcsinh</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]))</span>
<span class="go">array([ 1.72538256,  2.99822295])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arctan">
<code class="sig-name descname">arctan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arctan" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric inverse tangent, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arctan" title="symjax.tensor.arctan"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arctan" title="symjax.tensor.arctan"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan()</span></code></a>.
Original docstring below.</p>
<p>arctan(x, /, out=None, <a href="#id19"><span class="problematic" id="id20">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The inverse of tan, so that if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">tan(x)</span></code> then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">arctan(y)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Out has the same shape as <cite>x</cite>.  Its real part is in
<code class="docutils literal notranslate"><span class="pre">[-pi/2,</span> <span class="pre">pi/2]</span></code> (<code class="docutils literal notranslate"><span class="pre">arctan(+/-inf)</span></code> returns <code class="docutils literal notranslate"><span class="pre">+/-pi/2</span></code>).
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.arctan2" title="symjax.tensor.arctan2"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan2()</span></code></a></dt><dd><p>The “four quadrant” arctan of the angle formed by (<cite>x</cite>, <cite>y</cite>) and the positive <cite>x</cite>-axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.angle" title="symjax.tensor.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a></dt><dd><p>Argument of complex values.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>arctan</cite> is a multi-valued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that tan(<cite>z</cite>) = <cite>x</cite>.  The convention is to return
the angle <cite>z</cite> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <cite>arctan</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arctan</cite> is a complex analytic function that
has [<cite>1j, infj</cite>] and [<cite>-1j, -infj</cite>] as branch cuts, and is continuous
from the left on the former and from the right on the latter.</p>
<p>The inverse tangent is also known as <cite>atan</cite> or tan^{-1}.</p>
<p class="rubric">References</p>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>,
10th printing, New York: Dover, 1964, pp. 79.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p class="rubric">Examples</p>
<p>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 0.        ,  0.78539816])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span>
<span class="go">0.78539816339744828</span>
</pre></div>
</div>
<p>Plot arctan:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arctan2">
<code class="sig-name descname">arctan2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arctan2" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise arc tangent of <code class="docutils literal notranslate"><span class="pre">x1/x2</span></code> choosing the quadrant correctly.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arctan2" title="symjax.tensor.arctan2"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan2()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arctan2" title="symjax.tensor.arctan2"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan2()</span></code></a>.
Original docstring below.</p>
<p>arctan2(x1, x2, /, out=None, <a href="#id21"><span class="problematic" id="id22">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The quadrant (i.e., branch) is chosen so that <code class="docutils literal notranslate"><span class="pre">arctan2(x1,</span> <span class="pre">x2)</span></code> is
the signed angle in radians between the ray ending at the origin and
passing through the point (1,0), and the ray ending at the origin and
passing through the point (<cite>x2</cite>, <cite>x1</cite>).  (Note the role reversal: the
“<cite>y</cite>-coordinate” is the first function parameter, the “<cite>x</cite>-coordinate”
is the second.)  By IEEE convention, this function is defined for
<cite>x2</cite> = +/-0 and for either or both of <cite>x1</cite> and <cite>x2</cite> = +/-inf (see
Notes for specific values).</p>
<p>This function is not defined for complex-valued arguments; for the
so-called argument of complex values, use <cite>angle</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>angle</strong> – Array of angles in radians, in the range <code class="docutils literal notranslate"><span class="pre">[-pi,</span> <span class="pre">pi]</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.arctan" title="symjax.tensor.arctan"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctan()</span></code></a>, <a class="reference internal" href="#symjax.tensor.tan" title="symjax.tensor.tan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tan()</span></code></a>, <a class="reference internal" href="#symjax.tensor.angle" title="symjax.tensor.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p><em>arctan2</em> is identical to the <cite>atan2</cite> function of the underlying
C library.  The following special values are defined in the C
standard: <a href="#id173"><span class="problematic" id="id23">[1]_</span></a></p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 21%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>x1</cite></p></th>
<th class="head"><p><cite>x2</cite></p></th>
<th class="head"><p><cite>arctan2(x1,x2)</cite></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>+/- 0</p></td>
<td><p>+0</p></td>
<td><p>+/- 0</p></td>
</tr>
<tr class="row-odd"><td><p>+/- 0</p></td>
<td><p>-0</p></td>
<td><p>+/- pi</p></td>
</tr>
<tr class="row-even"><td><p>&gt; 0</p></td>
<td><p>+/-inf</p></td>
<td><p>+0 / +pi</p></td>
</tr>
<tr class="row-odd"><td><p>&lt; 0</p></td>
<td><p>+/-inf</p></td>
<td><p>-0 / -pi</p></td>
</tr>
<tr class="row-even"><td><p>+/-inf</p></td>
<td><p>+inf</p></td>
<td><p>+/- (pi/4)</p></td>
</tr>
<tr class="row-odd"><td><p>+/-inf</p></td>
<td><p>-inf</p></td>
<td><p>+/- (3*pi/4)</p></td>
</tr>
</tbody>
</table>
<p>Note that +0 and -0 are distinct floating point numbers, as are +inf
and -inf.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id24"><span class="brackets">1</span></dt>
<dd><p>ISO/IEC standard 9899:1999, “Programming language C.”</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Consider four points in different quadrants:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="go">array([-135.,  -45.,   45.,  135.])</span>
</pre></div>
</div>
<p>Note the order of the parameters. <cite>arctan2</cite> is defined also when <cite>x2</cite> = 0
and at several other special points, obtaining values in
the range <code class="docutils literal notranslate"><span class="pre">[-pi,</span> <span class="pre">pi]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
<span class="go">array([ 1.57079633, -1.57079633])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">+</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">array([ 0.        ,  3.14159265,  0.78539816])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.arctanh">
<code class="sig-name descname">arctanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.arctanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse hyperbolic tangent element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arctanh" title="symjax.tensor.arctanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctanh()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.arctanh" title="symjax.tensor.arctanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">arctanh()</span></code></a>.
Original docstring below.</p>
<p>arctanh(x, /, out=None, <a href="#id25"><span class="problematic" id="id26">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Array of the same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">emath.arctanh()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p><cite>arctanh</cite> is a multivalued function: for each <cite>x</cite> there are infinitely
many numbers <cite>z</cite> such that <cite>tanh(z) = x</cite>. The convention is to return
the <cite>z</cite> whose imaginary part lies in <cite>[-pi/2, pi/2]</cite>.</p>
<p>For real-valued input data types, <cite>arctanh</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>arctanh</cite> is a complex analytical function
that has branch cuts <cite>[-1, -inf]</cite> and <cite>[1, inf]</cite> and is continuous from
above on the former and from below on the latter.</p>
<p>The inverse hyperbolic tangent is also known as <cite>atanh</cite> or <code class="docutils literal notranslate"><span class="pre">tanh^-1</span></code>.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id27"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 86. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id28"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Inverse hyperbolic function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Arctanh">http://en.wikipedia.org/wiki/Arctanh</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">arctanh</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
<span class="go">array([ 0.        , -0.54930614])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.argmax">
<code class="sig-name descname">argmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#argmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the maximum values along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.argmax" title="symjax.tensor.argmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmax()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.argmax" title="symjax.tensor.argmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmax()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>index_array</strong> – Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of ints</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.argmax()</span></code>, <a class="reference internal" href="#symjax.tensor.argmin" title="symjax.tensor.argmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmin()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a></dt><dd><p>The maximum value along a given axis.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">unravel_index()</span></code></dt><dd><p>Convert a flat index into an index tuple.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
</pre></div>
</div>
<p>Indexes of the maximal elements of a N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 5, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.argmin">
<code class="sig-name descname">argmin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#argmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the minimum values along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.argmin" title="symjax.tensor.argmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmin()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.argmin" title="symjax.tensor.argmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmin()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>index_array</strong> – Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of ints</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.argmin()</span></code>, <a class="reference internal" href="#symjax.tensor.argmax" title="symjax.tensor.argmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmax()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a></dt><dd><p>The minimum value along a given axis.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">unravel_index()</span></code></dt><dd><p>Convert a flat index into an index tuple.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 0])</span>
</pre></div>
</div>
<p>Indices of the minimum elements of a N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 1, 2, 3, 0, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.argsort">
<code class="sig-name descname">argsort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'quicksort'</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#argsort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices that would sort an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.argsort" title="symjax.tensor.argsort"><code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.argsort" title="symjax.tensor.argsort"><code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code></a>.
Original docstring below.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified
by the <cite>kind</cite> keyword. It returns an array of indices of the same shape as
<cite>a</cite> that index data along the given axis in sorted order.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>index_array</strong> – Array of indices that sort <cite>a</cite> along the specified axis.
If <cite>a</cite> is one-dimensional, <code class="docutils literal notranslate"><span class="pre">a[index_array]</span></code> yields a sorted <cite>a</cite>.
More generally, <code class="docutils literal notranslate"><span class="pre">np.take_along_axis(a,</span> <span class="pre">index_array,</span> <span class="pre">axis=a)</span></code> always
yields the sorted <cite>a</cite>, irrespective of dimensionality.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray, int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.sort" title="symjax.tensor.sort"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort()</span></code></a></dt><dd><p>Describes sorting algorithms used.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">lexsort()</span></code></dt><dd><p>Indirect stable sort with multiple keys.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.sort()</span></code></dt><dd><p>Inplace sort.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">argpartition()</span></code></dt><dd><p>Indirect partial sort.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>See <cite>sort</cite> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <cite>argsort</cite> works with real/complex arrays containing
nan values. The enhanced sort order is documented in <cite>sort</cite>.</p>
<p class="rubric">Examples</p>
<p>One dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([1, 2, 0])</span>
</pre></div>
</div>
<p>Two-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sorts along first axis (down)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sorts along last axis (across)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [0, 1]])</span>
</pre></div>
</div>
<p>Indices of the sorted elements of a N-dimensional array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(array([0, 1, 1, 0]), array([0, 0, 1, 1]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>  <span class="c1"># same as np.sort(x, axis=None)</span>
<span class="go">array([0, 2, 2, 3])</span>
</pre></div>
</div>
<p>Sorting with keys:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;i4&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([(1, 0), (0, 1)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">))</span>
<span class="go">array([1, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">))</span>
<span class="go">array([0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.around">
<code class="sig-name descname">around</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">decimals</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.around" title="Permalink to this definition">¶</a></dt>
<dd><p>Round an array to the given number of decimals.</p>
<p>LAX-backend implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">round_()</span></code>.
ADDITIONOriginal docstring below.</p>
<p>LA</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.asarray">
<code class="sig-name descname">asarray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#asarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the input to an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.asarray" title="symjax.tensor.asarray"><code class="xref py py-func docutils literal notranslate"><span class="pre">asarray()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.asarray" title="symjax.tensor.asarray"><code class="xref py py-func docutils literal notranslate"><span class="pre">asarray()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – By default, the data-type is inferred from the input data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array interpretation of <cite>a</cite>.  No copy is performed if the input
is already an ndarray with matching dtype and order.  If <cite>a</cite> is a
subclass of ndarray, a base class ndarray is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">asanyarray()</span></code></dt><dd><p>Similar function which passes through subclasses.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ascontiguousarray()</span></code></dt><dd><p>Convert input to a contiguous array.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">asfarray()</span></code></dt><dd><p>Convert input to a floating point ndarray.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">asfortranarray()</span></code></dt><dd><p>Convert input to an ndarray with column-major memory order.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">asarray_chkfinite()</span></code></dt><dd><p>Similar function which checks input for NaNs and Infs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fromiter()</span></code></dt><dd><p>Create an array from an iterator.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fromfunction()</span></code></dt><dd><p>Construct an array by executing a function on grid positions.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Convert a list into an array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Existing arrays are not copied:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>dtype</cite> is set, array is copied only if dtype does not match:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Contrary to <cite>asanyarray</cite>, ndarray subclasses are not passed through:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f4,i4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.atleast_1d">
<code class="sig-name descname">atleast_1d</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">arys</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#atleast_1d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.atleast_1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert inputs to arrays with at least one dimension.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.atleast_1d" title="symjax.tensor.atleast_1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_1d()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.atleast_1d" title="symjax.tensor.atleast_1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_1d()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>Scalar inputs are converted to 1-dimensional arrays, whilst
higher-dimensional inputs are preserved.</p>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>ret<span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code>.
Copies are made only if necessary.</p>
</dd>
</dl>
<p>atleast_2d, atleast_3d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="go">array([ 1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  2.],</span>
<span class="go">       [ 3.,  4.,  5.],</span>
<span class="go">       [ 6.,  7.,  8.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">[array([1]), array([3, 4])]</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.atleast_2d">
<code class="sig-name descname">atleast_2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">arys</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#atleast_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.atleast_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least two dimensions.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.atleast_2d" title="symjax.tensor.atleast_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_2d()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.atleast_2d" title="symjax.tensor.atleast_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_2d()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>res, res2, …<span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code>.
Copies are avoided where possible, and views with two or more
dimensions are returned.</p>
</dd>
</dl>
<p>atleast_1d, atleast_3d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([[ 3.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="go">[array([[1]]), array([[1, 2]]), array([[1, 2]])]</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.atleast_3d">
<code class="sig-name descname">atleast_3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">arys</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#atleast_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.atleast_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>View inputs as arrays with at least three dimensions.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.atleast_3d" title="symjax.tensor.atleast_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_3d()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.atleast_3d" title="symjax.tensor.atleast_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_3d()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>res1, res2, …<span class="classifier">ndarray</span></dt><dd><p>An array, or list of arrays, each with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>.  Copies are
avoided where possible, and views with three or more dimensions are
returned.  For example, a 1-D array of shape <code class="docutils literal notranslate"><span class="pre">(N,)</span></code> becomes a view
of shape <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>, and a 2-D array of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N)</span></code> becomes a
view of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">N,</span> <span class="pre">1)</span></code>.</p>
</dd>
</dl>
<p>atleast_1d, atleast_2d</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="go">array([[[ 3.]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">12.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">base</span>  <span class="c1"># x is a reshape, so not base itself</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1]</span>
<span class="go">  [2]]] (1, 2, 1)</span>
<span class="go">[[[1 2]]] (1, 1, 2)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.bitwise_and">
<code class="sig-name descname">bitwise_and</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.bitwise_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bit-wise AND of two arrays element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.bitwise_and" title="symjax.tensor.bitwise_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_and()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.bitwise_and" title="symjax.tensor.bitwise_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_and()</span></code></a>.
Original docstring below.</p>
<p>bitwise_and(x1, x2, /, out=None, <a href="#id29"><span class="problematic" id="id30">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Computes the bit-wise AND of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Result.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_and" title="symjax.tensor.logical_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_or" title="symjax.tensor.bitwise_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_or()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_xor" title="symjax.tensor.bitwise_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_xor()</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_repr()</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The number 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>.  Likewise, 17 is
represented by <code class="docutils literal notranslate"><span class="pre">00010001</span></code>.  The bit-wise AND of 13 and 17 is
therefore <code class="docutils literal notranslate"><span class="pre">000000001</span></code>, or 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="go">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">&#39;1100&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">([</span><span class="mi">14</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">13</span><span class="p">)</span>
<span class="go">array([12,  1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">25</span><span class="p">])</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">255</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">]))</span>
<span class="go">array([ 2,  4, 16])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.bitwise_not">
<code class="sig-name descname">bitwise_not</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.bitwise_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>LAX-backend implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">invert()</span></code>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">invert()</span></code>.
Original docstring below.</p>
<p>invert(x, /, out=None, <a href="#id31"><span class="problematic" id="id32">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Computes the bit-wise NOT of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
<p>For signed integer inputs, the two’s complement is returned.  In a
two’s-complement system negative numbers are represented by the two’s
complement of the absolute value. This is the most common method of
representing signed integers on computers <a href="#id174"><span class="problematic" id="id33">[1]_</span></a>. A N-bit
two’s-complement system can represent every integer in the range
<span class="math notranslate nohighlight">\(-2^{N-1}\)</span> to <span class="math notranslate nohighlight">\(+2^{N-1}-1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Result.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.bitwise_and" title="symjax.tensor.bitwise_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_or" title="symjax.tensor.bitwise_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_or()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_xor" title="symjax.tensor.bitwise_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_xor()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_not" title="symjax.tensor.logical_not"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_not()</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_repr()</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><cite>bitwise_not</cite> is an alias for <cite>invert</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id34"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, “Two’s complement”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Two's_complement">http://en.wikipedia.org/wiki/Two’s_complement</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>We’ve seen that 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>.
The invert or bit-wise NOT of 13 is then:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">13</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">))</span>
<span class="go">array([242], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;00001101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">242</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;11110010&#39;</span>
</pre></div>
</div>
<p>The result depends on the bit-width:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">13</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint16</span><span class="p">))</span>
<span class="go">array([65522], dtype=uint16)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;0000000000001101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">65522</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="go">&#39;1111111111110010&#39;</span>
</pre></div>
</div>
<p>When using signed integer types the result is the two’s complement of
the result for the unsigned type:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">13</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int8</span><span class="p">))</span>
<span class="go">array([-14], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="go">&#39;11110010&#39;</span>
</pre></div>
</div>
<p>Booleans are accepted as well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]))</span>
<span class="go">array([False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.bitwise_or">
<code class="sig-name descname">bitwise_or</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.bitwise_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bit-wise OR of two arrays element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.bitwise_or" title="symjax.tensor.bitwise_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_or()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.bitwise_or" title="symjax.tensor.bitwise_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_or()</span></code></a>.
Original docstring below.</p>
<p>bitwise_or(x1, x2, /, out=None, <a href="#id35"><span class="problematic" id="id36">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Computes the bit-wise OR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">|</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Result.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_or" title="symjax.tensor.logical_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_or()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_and" title="symjax.tensor.bitwise_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_xor" title="symjax.tensor.bitwise_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_xor()</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_repr()</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The number 13 has the binaray representation <code class="docutils literal notranslate"><span class="pre">00001101</span></code>. Likewise,
16 is represented by <code class="docutils literal notranslate"><span class="pre">00010000</span></code>.  The bit-wise OR of 13 and 16 is
then <code class="docutils literal notranslate"><span class="pre">000111011</span></code>, or 29:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="go">29</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">29</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">([</span><span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([33,  5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">([</span><span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([33,  6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">255</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span>
<span class="go">array([  6,   5, 255])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">array([  6,   5, 255])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">2147483647</span><span class="n">L</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2147483647</span><span class="n">L</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
<span class="go">array([         6,          5,        255, 2147483647])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">array([ True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.bitwise_xor">
<code class="sig-name descname">bitwise_xor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.bitwise_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bit-wise XOR of two arrays element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.bitwise_xor" title="symjax.tensor.bitwise_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_xor()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.bitwise_xor" title="symjax.tensor.bitwise_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_xor()</span></code></a>.
Original docstring below.</p>
<p>bitwise_xor(x1, x2, /, out=None, <a href="#id37"><span class="problematic" id="id38">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Computes the bit-wise XOR of the underlying binary representation of
the integers in the input arrays. This ufunc implements the C/Python
operator <code class="docutils literal notranslate"><span class="pre">^</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Result.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_xor" title="symjax.tensor.logical_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_and" title="symjax.tensor.bitwise_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_or" title="symjax.tensor.bitwise_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_or()</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_repr()</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The number 13 is represented by <code class="docutils literal notranslate"><span class="pre">00001101</span></code>. Likewise, 17 is
represented by <code class="docutils literal notranslate"><span class="pre">00010001</span></code>.  The bit-wise XOR of 13 and 17 is
therefore <code class="docutils literal notranslate"><span class="pre">00011100</span></code>, or 28:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="go">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">28</span><span class="p">)</span>
<span class="go">&#39;11100&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="mi">31</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([26,  6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">([</span><span class="mi">31</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="go">array([26,  5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.block">
<code class="sig-name descname">block</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arrays</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.block" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble an nd-array from nested lists of blocks.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.block" title="symjax.tensor.block"><code class="xref py py-func docutils literal notranslate"><span class="pre">block()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.block" title="symjax.tensor.block"><code class="xref py py-func docutils literal notranslate"><span class="pre">block()</span></code></a>.
Original docstring below.</p>
<p>Blocks in the innermost lists are concatenated (see <cite>concatenate</cite>) along
the last dimension (-1), then these are concatenated along the
second-last dimension (-2), and so on until the outermost list is reached.</p>
<p>Blocks can be of any dimension, but will not be broadcasted using the normal
rules. Instead, leading axes of size 1 are inserted, to make <code class="docutils literal notranslate"><span class="pre">block.ndim</span></code>
the same for all blocks. This is primarily useful for working with scalars,
and means that code like <code class="docutils literal notranslate"><span class="pre">np.block([v,</span> <span class="pre">1])</span></code> is valid, where
<code class="docutils literal notranslate"><span class="pre">v.ndim</span> <span class="pre">==</span> <span class="pre">1</span></code>.</p>
<p>When the nested list is two levels deep, this allows block matrices to be
constructed from their components.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>block_array</strong> – The array assembled from the given blocks.</p>
<p>The dimensionality of the output is equal to the greatest of:
* the dimensionality of all the inputs
* the depth to which the input list is nested</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – <ul class="simple">
<li><p>If list depths are mismatched - for instance, <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">c]</span></code> is
      illegal, and should be spelt <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[c]]</span></code>
    * If lists are empty - for instance, <code class="docutils literal notranslate"><span class="pre">[[a,</span> <span class="pre">b],</span> <span class="pre">[]]</span></code></p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays together.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a></dt><dd><p>Stack arrays in sequence along a new dimension.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a></dt><dd><p>Stack arrays in sequence horizontally (column wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a></dt><dd><p>Stack arrays in sequence vertically (row wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third dimension).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vsplit" title="symjax.tensor.vsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">vsplit()</span></code></a></dt><dd><p>Split array into a list of multiple sub-arrays vertically.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>When called with only scalars, <code class="docutils literal notranslate"><span class="pre">np.block</span></code> is equivalent to an ndarray
call. So <code class="docutils literal notranslate"><span class="pre">np.block([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">np.array([[1,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">4]])</span></code>.</p>
<p>This function does not enforce that the blocks lie on a fixed grid.
<code class="docutils literal notranslate"><span class="pre">np.block([[a,</span> <span class="pre">b],</span> <span class="pre">[c,</span> <span class="pre">d]])</span></code> is not restricted to arrays of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>But is also allowed to produce, for some <code class="docutils literal notranslate"><span class="pre">a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">AAAbb</span>
<span class="n">cDDDD</span>
</pre></div>
</div>
<p>Since concatenation happens along the last axis first, <cite>block</cite> is _not_
capable of producing the following directly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AAAbb</span>
<span class="n">cccbb</span>
<span class="n">cccDD</span>
</pre></div>
</div>
<p>Matlab’s “square bracket stacking”, <code class="docutils literal notranslate"><span class="pre">[A,</span> <span class="pre">B,</span> <span class="pre">...;</span> <span class="pre">p,</span> <span class="pre">q,</span> <span class="pre">...]</span></code>, is
equivalent to <code class="docutils literal notranslate"><span class="pre">np.block([[A,</span> <span class="pre">B,</span> <span class="pre">...],</span> <span class="pre">[p,</span> <span class="pre">q,</span> <span class="pre">...]])</span></code>.</p>
<p class="rubric">Examples</p>
<p>The most common use of this function is to build a block matrix</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">A</span><span class="p">,</span>               <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">B</span>               <span class="p">]</span>
<span class="gp">... </span><span class="p">])</span>
<span class="go">array([[ 2.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  3.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  3.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  0.,  3.]])</span>
</pre></div>
</div>
<p>With a list of depth 1, <cite>block</cite> can be used as <cite>hstack</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>              <span class="c1"># hstack([1, 2, 3])</span>
<span class="go">array([1, 2, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>             <span class="c1"># hstack([a, b, 10])</span>
<span class="go">array([1, 2, 3, 2, 3, 4, 10])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">])</span>                 <span class="c1"># hstack([A, B])</span>
<span class="go">array([[1, 1, 2, 2],</span>
<span class="go">       [1, 1, 2, 2]])</span>
</pre></div>
</div>
<p>With a list of depth 2, <cite>block</cite> can be used in place of <cite>vstack</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">]])</span>             <span class="c1"># vstack([a, b])</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">A</span><span class="p">],</span> <span class="p">[</span><span class="n">B</span><span class="p">]])</span>             <span class="c1"># vstack([A, B])</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 2],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>It can also be used in places of <cite>atleast_1d</cite> and <cite>atleast_2d</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">a</span><span class="p">])</span>                    <span class="c1"># atleast_1d(a)</span>
<span class="go">array([0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([</span><span class="n">b</span><span class="p">])</span>                    <span class="c1"># atleast_1d(b)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">a</span><span class="p">]])</span>                  <span class="c1"># atleast_2d(a)</span>
<span class="go">array([[0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">b</span><span class="p">]])</span>                  <span class="c1"># atleast_2d(b)</span>
<span class="go">array([[1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.ceil">
<code class="sig-name descname">ceil</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ceiling of the input, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ceil" title="symjax.tensor.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ceil" title="symjax.tensor.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>.
Original docstring below.</p>
<p>ceil(x, /, out=None, <a href="#id39"><span class="problematic" id="id40">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The ceil of the scalar <cite>x</cite> is the smallest integer <cite>i</cite>, such that
<cite>i &gt;= x</cite>.  It is often denoted as <span class="math notranslate nohighlight">\(\lceil x \rceil\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The ceiling of each element in <cite>x</cite>, with <cite>float</cite> dtype.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.floor" title="symjax.tensor.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">rint()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([-1., -1., -0.,  1.,  2.,  2.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">a_min</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">a_max</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#clip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip (limit) the values in an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.clip" title="symjax.tensor.clip"><code class="xref py py-func docutils literal notranslate"><span class="pre">clip()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.clip" title="symjax.tensor.clip"><code class="xref py py-func docutils literal notranslate"><span class="pre">clip()</span></code></a>.
Original docstring below.</p>
<p>Given an interval, values outside the interval are clipped to
the interval edges.  For example, if an interval of <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1]</span></code>
is specified, values smaller than 0 become 0, and values larger
than 1 become 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>clipped_array</strong> – An array with the elements of <cite>a</cite>, but where values
&lt; <cite>a_min</cite> are replaced with <cite>a_min</cite>, and those &gt; <cite>a_max</cite>
with <cite>a_max</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.column_stack">
<code class="sig-name descname">column_stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tup</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#column_stack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.column_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack 1-D arrays as columns into a 2-D array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.column_stack" title="symjax.tensor.column_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_stack()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.column_stack" title="symjax.tensor.column_stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">column_stack()</span></code></a>.
Original docstring below.</p>
<p>Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with <cite>hstack</cite>.  1-D arrays are turned into 2-D columns
first.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>stacked</strong> – The array formed by stacking the given arrays.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>2-D array</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a>, <a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a>, <a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a>, <a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.concatenate">
<code class="sig-name descname">concatenate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arrays</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#concatenate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along an existing axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a>.
Original docstring below.</p>
<p>concatenate((a1, a2, …), axis=0, out=None)</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>res<span class="classifier">ndarray</span></dt><dd><p>The concatenated array.</p>
</dd>
</dl>
<p>ma.concatenate : Concatenate function that preserves input masks.
array_split : Split an array into multiple sub-arrays of equal or</p>
<blockquote>
<div><p>near-equal size.</p>
</div></blockquote>
<p>split : Split array into a list of multiple sub-arrays of equal size.
hsplit : Split array into multiple sub-arrays horizontally (column wise)
vsplit : Split array into multiple sub-arrays vertically (row wise)
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
stack : Stack a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise)
vstack : Stack arrays in sequence vertically (row wise)
dstack : Stack arrays in sequence depth wise (along third dimension)</p>
<p>When one or more of the arrays to be concatenated is a MaskedArray,
this function will return a MaskedArray object instead of an ndarray,
but the input masks are <em>not</em> preserved. In cases where a MaskedArray
is expected as input, use the ma.concatenate function from the masked
array module instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2, 5],</span>
<span class="go">       [3, 4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
</pre></div>
</div>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">masked_array(data = [0 -- 2],</span>
<span class="go">             mask = [False  True False],</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 1 2 2 3 4],</span>
<span class="go">             mask = False,</span>
<span class="go">       fill_value = 999999)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="go">masked_array(data = [0 -- 2 2 3 4],</span>
<span class="go">             mask = [False  True False False False False],</span>
<span class="go">       fill_value = 999999)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.conj">
<code class="sig-name descname">conj</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.conjugate" title="symjax.tensor.conjugate"><code class="xref py py-func docutils literal notranslate"><span class="pre">conjugate()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.conjugate" title="symjax.tensor.conjugate"><code class="xref py py-func docutils literal notranslate"><span class="pre">conjugate()</span></code></a>.
Original docstring below.</p>
<p>conjugate(x, /, out=None, <a href="#id41"><span class="problematic" id="id42">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The complex conjugate of <cite>x</cite>, with same dtype as <cite>y</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1-2j)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 1.-1.j,  0.-0.j],</span>
<span class="go">       [ 0.-0.j,  1.-1.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.conjugate">
<code class="sig-name descname">conjugate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#conjugate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex conjugate, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.conjugate" title="symjax.tensor.conjugate"><code class="xref py py-func docutils literal notranslate"><span class="pre">conjugate()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.conjugate" title="symjax.tensor.conjugate"><code class="xref py py-func docutils literal notranslate"><span class="pre">conjugate()</span></code></a>.
Original docstring below.</p>
<p>conjugate(x, /, out=None, <a href="#id43"><span class="problematic" id="id44">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The complex conjugate of a complex number is obtained by changing the
sign of its imaginary part.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The complex conjugate of <cite>x</cite>, with same dtype as <cite>y</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1-2j)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 1.-1.j,  0.-0.j],</span>
<span class="go">       [ 0.-0.j,  1.-1.j]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.corrcoef">
<code class="sig-name descname">corrcoef</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rowvar</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#corrcoef"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.corrcoef" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Pearson product-moment correlation coefficients.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.corrcoef" title="symjax.tensor.corrcoef"><code class="xref py py-func docutils literal notranslate"><span class="pre">corrcoef()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.corrcoef" title="symjax.tensor.corrcoef"><code class="xref py py-func docutils literal notranslate"><span class="pre">corrcoef()</span></code></a>.
Original docstring below.</p>
<p>Please refer to the documentation for <cite>cov</cite> for more detail.  The
relationship between the correlation coefficient matrix, <cite>R</cite>, and the
covariance matrix, <cite>C</cite>, is</p>
<div class="math notranslate nohighlight">
\[R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }\]</div>
<p>The values of <cite>R</cite> are between -1 and 1, inclusive.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>R</strong> – The correlation coefficient matrix of the variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.cov" title="symjax.tensor.cov"><code class="xref py py-func docutils literal notranslate"><span class="pre">cov()</span></code></a></dt><dd><p>Covariance matrix</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Due to floating point rounding the resulting array may not be Hermitian,
the diagonal elements may not be 1, and the elements may not satisfy the
inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
interval [-1,  1] in an attempt to improve on that situation but is not
much help in the complex case.</p>
<p>This function accepts but discards arguments <cite>bias</cite> and <cite>ddof</cite>.  This is
for backwards compatibility with previous versions of this function.  These
arguments had no effect on the return values of the function and can be
safely ignored in this and previous versions of numpy.</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cos">
<code class="sig-name descname">cos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cos" title="symjax.tensor.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">cos()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cos" title="symjax.tensor.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">cos()</span></code></a>.
Original docstring below.</p>
<p>cos(x, /, out=None, <a href="#id45"><span class="problematic" id="id46">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding cosine values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]))</span>
<span class="go">array([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">invalid return array shape</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cosh">
<code class="sig-name descname">cosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic cosine, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cosh" title="symjax.tensor.cosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">cosh()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cosh" title="symjax.tensor.cosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">cosh()</span></code></a>.
Original docstring below.</p>
<p>cosh(x, /, out=None, <a href="#id47"><span class="problematic" id="id48">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">1/2</span> <span class="pre">*</span> <span class="pre">(np.exp(x)</span> <span class="pre">+</span> <span class="pre">np.exp(-x))</span></code> and <code class="docutils literal notranslate"><span class="pre">np.cos(1j*x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array of same shape as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>The hyperbolic cosine describes the shape of a hanging cable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.count_nonzero">
<code class="sig-name descname">count_nonzero</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#count_nonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.count_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of non-zero values in the array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.count_nonzero" title="symjax.tensor.count_nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">count_nonzero()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.count_nonzero" title="symjax.tensor.count_nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">count_nonzero()</span></code></a>.
Original docstring below.</p>
<p>The word “non-zero” is in reference to the Python 2.x
built-in method <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> (renamed <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
in Python 3.x) of Python objects that tests an object’s
“truthfulness”. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in <code class="docutils literal notranslate"><span class="pre">a</span></code> (and in
sub-arrays thereof) have their <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> or <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
method evaluated to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>count</strong> – Number of non-zero values in the array along a given axis.
Otherwise, the total number of non-zero values in the array
is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int or array of int</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.nonzero" title="symjax.tensor.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a></dt><dd><p>Return the coordinates of all the non-zero values.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]])</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rowvar</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fweights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">aweights</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#cov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a covariance matrix, given data and weights.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cov" title="symjax.tensor.cov"><code class="xref py py-func docutils literal notranslate"><span class="pre">cov()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cov" title="symjax.tensor.cov"><code class="xref py py-func docutils literal notranslate"><span class="pre">cov()</span></code></a>.
Original docstring below.</p>
<p>Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, <span class="math notranslate nohighlight">\(X = [x_1, x_2, ... x_N]^T\)</span>,
then the covariance matrix element <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the covariance of
<span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_j\)</span>. The element <span class="math notranslate nohighlight">\(C_{ii}\)</span> is the variance
of <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>See the notes for an outline of the algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The covariance matrix of the variables.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.corrcoef" title="symjax.tensor.corrcoef"><code class="xref py py-func docutils literal notranslate"><span class="pre">corrcoef()</span></code></a></dt><dd><p>Normalized covariance matrix</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Assume that the observations are in the columns of the observation
array <cite>m</cite> and let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">fweights</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">aweights</span></code> for brevity. The
steps to compute the weighted covariance are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">v1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">/</span> <span class="p">(</span><span class="n">v1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that when <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">1</span></code>, the normalization factor
<code class="docutils literal notranslate"><span class="pre">v1</span> <span class="pre">/</span> <span class="pre">(v1**2</span> <span class="pre">-</span> <span class="pre">ddof</span> <span class="pre">*</span> <span class="pre">v2)</span></code> goes over to <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(np.sum(f)</span> <span class="pre">-</span> <span class="pre">ddof)</span></code>
as it should.</p>
<p class="rubric">Examples</p>
<p>Consider two variables, <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, which
correlate perfectly, but in opposite directions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [2, 1, 0]])</span>
</pre></div>
</div>
<p>Note how <span class="math notranslate nohighlight">\(x_0\)</span> increases while <span class="math notranslate nohighlight">\(x_1\)</span> decreases. The covariance
matrix shows this clearly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 1., -1.],</span>
<span class="go">       [-1.,  1.]])</span>
</pre></div>
</div>
<p>Note that element <span class="math notranslate nohighlight">\(C_{0,1}\)</span>, which shows the correlation between
<span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, is negative.</p>
<p>Further, note how <cite>x</cite> and <cite>y</cite> are combined:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mf">4.3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">0.12</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="go">[[ 11.71        -4.286     ]</span>
<span class="go"> [ -4.286        2.14413333]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">[[ 11.71        -4.286     ]</span>
<span class="go"> [ -4.286        2.14413333]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">11.71</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cross">
<code class="sig-name descname">cross</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">axisa</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">axisb</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">axisc</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#cross"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.cross" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cross product of two (arrays of) vectors.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cross" title="symjax.tensor.cross"><code class="xref py py-func docutils literal notranslate"><span class="pre">cross()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cross" title="symjax.tensor.cross"><code class="xref py py-func docutils literal notranslate"><span class="pre">cross()</span></code></a>.
Original docstring below.</p>
<p>The cross product of <cite>a</cite> and <cite>b</cite> in <span class="math notranslate nohighlight">\(R^3\)</span> is a vector perpendicular
to both <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are arrays of vectors, the vectors
are defined by the last axis of <cite>a</cite> and <cite>b</cite> by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either <cite>a</cite> or <cite>b</cite> is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>c</strong> – Vector cross product(s).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – When the dimension of the vector(s) in <cite>a</cite> and/or <cite>b</cite> does not
    equal 2 or 3.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.inner" title="symjax.tensor.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">inner()</span></code></a></dt><dd><p>Inner product</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.outer" title="symjax.tensor.outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">outer()</span></code></a></dt><dd><p>Outer product.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ix_" title="symjax.tensor.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_()</span></code></a></dt><dd><p>Construct index arrays.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.9.0.</span></p>
</div>
<p>Supports full broadcasting of the inputs.</p>
<p class="rubric">Examples</p>
<p>Vector cross-product.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([-3,  6, -3])</span>
</pre></div>
</div>
<p>One vector with dimension 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([12, -6, -3])</span>
</pre></div>
</div>
<p>Equivalently:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([12, -6, -3])</span>
</pre></div>
</div>
<p>Both vectors with dimension 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">-3</span>
</pre></div>
</div>
<p>Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the <cite>right-hand rule</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[-3,  6, -3],</span>
<span class="go">       [ 3, -6,  3]])</span>
</pre></div>
</div>
<p>The orientation of <cite>c</cite> can be changed using the <cite>axisc</cite> keyword.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axisc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-3,  3],</span>
<span class="go">       [ 6, -6],</span>
<span class="go">       [-3,  3]])</span>
</pre></div>
</div>
<p>Change the vector definition of <cite>x</cite> and <cite>y</cite> using <cite>axisa</cite> and <cite>axisb</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[ -6,  12,  -6],</span>
<span class="go">       [  0,   0,   0],</span>
<span class="go">       [  6, -12,   6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axisa</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisb</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[-24,  48, -24],</span>
<span class="go">       [-30,  60, -30],</span>
<span class="go">       [-36,  72, -36]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative sum of the elements along a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cumsum" title="symjax.tensor.cumsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumsum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cumsum" title="symjax.tensor.cumsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumsum()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cumsum_along_axis</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to <cite>out</cite> is returned. The
result has the same size as <cite>a</cite>, and the same shape as <cite>a</cite> if
<cite>axis</cite> is not None or <cite>a</cite> is a 1-d array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.sum" title="symjax.tensor.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a></dt><dd><p>Sum array elements.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">trapz()</span></code></dt><dd><p>Integration of array values using the composite trapezoidal rule.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">diff()</span></code></dt><dd><p>Calculate the n-th discrete difference along given axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1,  3,  6, 10, 15, 21])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>     <span class="c1"># specifies type of output value(s)</span>
<span class="go">array([  1.,   3.,   6.,  10.,  15.,  21.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>      <span class="c1"># sum over rows for each of the 3 columns</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [5, 7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>      <span class="c1"># sum over columns for each of the 2 rows</span>
<span class="go">array([[ 1,  3,  6],</span>
<span class="go">       [ 4,  9, 15]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of elements along a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cumprod" title="symjax.tensor.cumprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumprod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cumprod" title="symjax.tensor.cumprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumprod()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cumprod</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to out is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># intermediate results 1, 1*2</span>
<span class="gp">... </span>              <span class="c1"># total product 1*2*3 = 6</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># specify type of output</span>
<span class="go">array([   1.,    2.,    6.,   24.,  120.,  720.])</span>
</pre></div>
</div>
<p>The cumulative product for each column (i.e., over the rows) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4, 10, 18]])</span>
</pre></div>
</div>
<p>The cumulative product for each row (i.e. over the columns) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  1,   2,   6],</span>
<span class="go">       [  4,  20, 120]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.cumproduct">
<code class="sig-name descname">cumproduct</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.cumproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cumulative product of elements along a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cumprod" title="symjax.tensor.cumprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumprod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.cumprod" title="symjax.tensor.cumprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumprod()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cumprod</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which case a reference to out is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># intermediate results 1, 1*2</span>
<span class="gp">... </span>              <span class="c1"># total product 1*2*3 = 6</span>
<span class="go">array([1, 2, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># specify type of output</span>
<span class="go">array([   1.,    2.,    6.,   24.,  120.,  720.])</span>
</pre></div>
</div>
<p>The cumulative product for each column (i.e., over the rows) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1,  2,  3],</span>
<span class="go">       [ 4, 10, 18]])</span>
</pre></div>
</div>
<p>The cumulative product for each row (i.e. over the columns) of <cite>a</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[  1,   2,   6],</span>
<span class="go">       [  4,  20, 120]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.deg2rad">
<code class="sig-name descname">deg2rad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#deg2rad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.deg2rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from degrees to radians.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.deg2rad" title="symjax.tensor.deg2rad"><code class="xref py py-func docutils literal notranslate"><span class="pre">deg2rad()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.deg2rad" title="symjax.tensor.deg2rad"><code class="xref py py-func docutils literal notranslate"><span class="pre">deg2rad()</span></code></a>.
Original docstring below.</p>
<p>deg2rad(x, /, out=None, <a href="#id49"><span class="problematic" id="id50">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding angle in radians.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.rad2deg" title="symjax.tensor.rad2deg"><code class="xref py py-func docutils literal notranslate"><span class="pre">rad2deg()</span></code></a></dt><dd><p>Convert angles from radians to degrees.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap()</span></code></dt><dd><p>Remove large jumps in angle by wrapping.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">deg2rad(x)</span></code> is <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">pi</span> <span class="pre">/</span> <span class="pre">180</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">180</span><span class="p">)</span>
<span class="go">3.1415926535897931</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.degrees">
<code class="sig-name descname">degrees</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from radians to degrees.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.rad2deg" title="symjax.tensor.rad2deg"><code class="xref py py-func docutils literal notranslate"><span class="pre">rad2deg()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.rad2deg" title="symjax.tensor.rad2deg"><code class="xref py py-func docutils literal notranslate"><span class="pre">rad2deg()</span></code></a>.
Original docstring below.</p>
<p>rad2deg(x, /, out=None, <a href="#id51"><span class="problematic" id="id52">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding angle in degrees.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.deg2rad" title="symjax.tensor.deg2rad"><code class="xref py py-func docutils literal notranslate"><span class="pre">deg2rad()</span></code></a></dt><dd><p>Convert angles from degrees to radians.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap()</span></code></dt><dd><p>Remove large jumps in angle by wrapping.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>rad2deg(x) is <code class="docutils literal notranslate"><span class="pre">180</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">/</span> <span class="pre">pi</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">90.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.diag">
<code class="sig-name descname">diag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#diag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a diagonal or construct a diagonal array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.diag" title="symjax.tensor.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.diag" title="symjax.tensor.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag()</span></code></a>.
Original docstring below.</p>
<p>See the more detailed documentation for <code class="docutils literal notranslate"><span class="pre">numpy.diagonal</span></code> if you use this
function to extract a diagonal and wish to write to the resulting array;
whether it returns a copy or a view depends on what version of numpy you
are using.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The extracted diagonal or constructed diagonal array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.diagonal" title="symjax.tensor.diagonal"><code class="xref py py-func docutils literal notranslate"><span class="pre">diagonal()</span></code></a></dt><dd><p>Return specified diagonals.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">diagflat()</span></code></dt><dd><p>Create a 2-D array with the flattened input as a diagonal.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.trace" title="symjax.tensor.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">trace()</span></code></a></dt><dd><p>Sum along diagonals.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.triu" title="symjax.tensor.triu"><code class="xref py py-func docutils literal notranslate"><span class="pre">triu()</span></code></a></dt><dd><p>Upper triangle of an array.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.tril" title="symjax.tensor.tril"><code class="xref py py-func docutils literal notranslate"><span class="pre">tril()</span></code></a></dt><dd><p>Lower triangle of an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [6, 7, 8]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([0, 4, 8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([3, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 4, 0],</span>
<span class="go">       [0, 0, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.diag_indices">
<code class="sig-name descname">diag_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">ndim</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#diag_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.diag_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices to access the main diagonal of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.diag_indices" title="symjax.tensor.diag_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag_indices()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.diag_indices" title="symjax.tensor.diag_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag_indices()</span></code></a>.
Original docstring below.</p>
<p>This returns a tuple of indices that can be used to access the main
diagonal of an array <cite>a</cite> with <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> dimensions and shape
(n, n, …, n). For <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">=</span> <span class="pre">2</span></code> this is the usual diagonal, for
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code> this is the set of indices to access <code class="docutils literal notranslate"><span class="pre">a[i,</span> <span class="pre">i,</span> <span class="pre">...,</span> <span class="pre">i]</span></code>
for <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">[0..n-1]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>)</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.diagonal">
<code class="sig-name descname">diagonal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">axis1</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">axis2</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#diagonal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.diagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return specified diagonals.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.diagonal" title="symjax.tensor.diagonal"><code class="xref py py-func docutils literal notranslate"><span class="pre">diagonal()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.diagonal" title="symjax.tensor.diagonal"><code class="xref py py-func docutils literal notranslate"><span class="pre">diagonal()</span></code></a>.
Original docstring below.</p>
<p>If <cite>a</cite> is 2-D, returns the diagonal of <cite>a</cite> with the given offset,
i.e., the collection of elements of the form <code class="docutils literal notranslate"><span class="pre">a[i,</span> <span class="pre">i+offset]</span></code>.  If
<cite>a</cite> has more than two dimensions, then the axes specified by <cite>axis1</cite>
and <cite>axis2</cite> are used to determine the 2-D sub-array whose diagonal is
returned.  The shape of the resulting array can be determined by
removing <cite>axis1</cite> and <cite>axis2</cite> and appending an index to the right equal
to the size of the resulting diagonals.</p>
<p>In versions of NumPy prior to 1.7, this function always returned a new,
independent array containing a copy of the values in the diagonal.</p>
<p>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
but depending on this fact is deprecated. Writing to the resulting
array continues to work as it used to, but a FutureWarning is issued.</p>
<p>Starting in NumPy 1.9 it returns a read-only view on the original array.
Attempting to write to the resulting array will produce an error.</p>
<p>In some future release, it will return a read/write view and writing to
the returned array will alter your original array.  The returned array
will have the same type as the input array.</p>
<p>If you don’t write to the array returned by this function, then you can
just ignore all of the above.</p>
<p>If you depend on the current behavior, then we suggest copying the
returned array explicitly, i.e., use <code class="docutils literal notranslate"><span class="pre">np.diagonal(a).copy()</span></code> instead
of just <code class="docutils literal notranslate"><span class="pre">np.diagonal(a)</span></code>. This will work with both past and future
versions of NumPy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>array_of_diagonals</strong> – If <cite>a</cite> is 2-D, then a 1-D array containing the diagonal and of the
same type as <cite>a</cite> is returned unless <cite>a</cite> is a <cite>matrix</cite>, in which case
a 1-D array rather than a (2-D) <cite>matrix</cite> is returned in order to
maintain backward compatibility.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">&gt;</span> <span class="pre">2</span></code>, then the dimensions specified by <cite>axis1</cite> and <cite>axis2</cite>
are removed, and a new axis inserted at the end corresponding to the
diagonal.</p>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the dimension of <cite>a</cite> is less than 2.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.diag" title="symjax.tensor.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag()</span></code></a></dt><dd><p>MATLAB work-a-like for 1-D and 2-D arrays.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">diagflat()</span></code></dt><dd><p>Create diagonal arrays.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.trace" title="symjax.tensor.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">trace()</span></code></a></dt><dd><p>Sum along diagonals.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
<span class="go">array([0, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
</pre></div>
</div>
<p>A 3-D example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># Main diagonals of two arrays created by skipping</span>
<span class="gp">... </span>           <span class="mi">0</span><span class="p">,</span> <span class="c1"># across the outer(left)-most axis last and</span>
<span class="gp">... </span>           <span class="mi">1</span><span class="p">)</span> <span class="c1"># the &quot;middle&quot; (row) axis first.</span>
<span class="go">array([[0, 6],</span>
<span class="go">       [1, 7]])</span>
</pre></div>
</div>
<p>The sub-arrays whose main diagonals we just obtained; note that each
corresponds to fixing the right-most (column) axis, and that the
diagonals are “packed” in rows.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># main diagonal is [0 6]</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [4, 6]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># main diagonal is [1 7]</span>
<span class="go">array([[1, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.divide">
<code class="sig-name descname">divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a true division of the inputs, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.true_divide" title="symjax.tensor.true_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">true_divide()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.true_divide" title="symjax.tensor.true_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">true_divide()</span></code></a>.
Original docstring below.</p>
<p>true_divide(x1, x2, /, out=None, <a href="#id53"><span class="problematic" id="id54">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Instead of the Python traditional ‘floor division’, this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The floor division operator <code class="docutils literal notranslate"><span class="pre">//</span></code> was added in Python 2.2 making
<code class="docutils literal notranslate"><span class="pre">//</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> equivalent operators.  The default floor division
operation of <code class="docutils literal notranslate"><span class="pre">/</span></code> can be replaced by true division with <code class="docutils literal notranslate"><span class="pre">from</span>
<span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>.</p>
<p>In Python 3.0, <code class="docutils literal notranslate"><span class="pre">//</span></code> is the floor division operator and <code class="docutils literal notranslate"><span class="pre">/</span></code> the
true division operator.  The <code class="docutils literal notranslate"><span class="pre">true_divide(x1,</span> <span class="pre">x2)</span></code> function is
equivalent to true division in Python.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">/</span><span class="mi">4</span>
<span class="go">array([0, 0, 0, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">//</span><span class="mi">4</span>
<span class="go">array([0, 0, 0, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">/</span><span class="mi">4</span>
<span class="go">array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">//</span><span class="mi">4</span>
<span class="go">array([0, 0, 0, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.divmod">
<code class="sig-name descname">divmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#divmod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.divmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return element-wise quotient and remainder simultaneously.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.divmod" title="symjax.tensor.divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.divmod" title="symjax.tensor.divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a>.
Original docstring below.</p>
<p>divmod(x1, x2[, out1, out2], / [, out=(None, None)], <a href="#id55"><span class="problematic" id="id56">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">np.divmod(x,</span> <span class="pre">y)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">//</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">%</span> <span class="pre">y)</span></code>, but faster
because it avoids redundant work. It is used to implement the Python
built-in function <code class="docutils literal notranslate"><span class="pre">divmod</span></code> on NumPy arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>out1</strong> (<em>ndarray</em>) – Element-wise quotient resulting from floor division.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p></li>
<li><p><strong>out2</strong> (<em>ndarray</em>) – Element-wise remainder from floor division.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.floor_divide" title="symjax.tensor.floor_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor_divide()</span></code></a></dt><dd><p>Equivalent to Python’s <code class="docutils literal notranslate"><span class="pre">//</span></code> operator.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a></dt><dd><p>Equivalent to Python’s <code class="docutils literal notranslate"><span class="pre">%</span></code> operator.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">modf()</span></code></dt><dd><p>Equivalent to <code class="docutils literal notranslate"><span class="pre">divmod(x,</span> <span class="pre">1)</span></code> for positive <code class="docutils literal notranslate"><span class="pre">x</span></code> with the return values switched.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.dot">
<code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">precision</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays. Specifically,</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.dot" title="symjax.tensor.dot"><code class="xref py py-func docutils literal notranslate"><span class="pre">dot()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.dot" title="symjax.tensor.dot"><code class="xref py py-func docutils literal notranslate"><span class="pre">dot()</span></code></a>.
In addition to the original NumPy arguments listed below, also supports
<code class="docutils literal notranslate"><span class="pre">precision</span></code> for extra control over matrix-multiplication precision
on supported devices. See <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.lax.dot()</span></code> for details.</p>
<p>Original docstring below.</p>
<p>dot(a, b, out=None)</p>
<blockquote>
<div><blockquote>
<div><ul>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p></li>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 2-D arrays, it is matrix multiplication,
but using <a class="reference internal" href="#symjax.tensor.matmul" title="symjax.tensor.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code></a> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If either <cite>a</cite> or <cite>b</cite> is 0-D (scalar), it is equivalent to <a class="reference internal" href="#symjax.tensor.multiply" title="symjax.tensor.multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code></a>
and using <code class="docutils literal notranslate"><span class="pre">numpy.multiply(a,</span> <span class="pre">b)</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is a 1-D array, it is a sum product over
the last axis of <cite>a</cite> and <cite>b</cite>.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is an M-D array (where <code class="docutils literal notranslate"><span class="pre">M&gt;=2</span></code>), it is a
sum product over the last axis of <cite>a</cite> and the second-to-last axis of <cite>b</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
</dd>
</dl>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
matmul : ‘&#64;’ operator as method with out parameter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Neither argument is complex-conjugated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>For 2-D arrays it is the matrix product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="mi">6</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="go">499128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">499128</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.dsplit">
<code class="sig-name descname">dsplit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ary</span></em>, <em class="sig-param"><span class="n">indices_or_sections</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.dsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.dsplit" title="symjax.tensor.dsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">dsplit()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LA</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.dstack">
<code class="sig-name descname">dstack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tup</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#dstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.dstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence depth wise (along third axis).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a>.
Original docstring below.</p>
<p>This is equivalent to concatenation along the third axis after 2-D arrays
of shape <cite>(M,N)</cite> have been reshaped to <cite>(M,N,1)</cite> and 1-D arrays of shape
<cite>(N,)</cite> have been reshaped to <cite>(1,N,1)</cite>. Rebuilds arrays divided by
<cite>dsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>stacked</strong> – The array formed by stacking the given arrays, will be at least 3-D.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a></dt><dd><p>Stack along first axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a></dt><dd><p>Stack along second axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dsplit" title="symjax.tensor.dsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">dsplit()</span></code></a></dt><dd><p>Split array along third axis.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[[1, 2],</span>
<span class="go">        [2, 3],</span>
<span class="go">        [3, 4]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[[1, 2]],</span>
<span class="go">       [[2, 3]],</span>
<span class="go">       [[3, 4]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.einsum">
<code class="sig-name descname">einsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">operands</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#einsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.einsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the Einstein summation convention on the operands.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.einsum" title="symjax.tensor.einsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">einsum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.einsum" title="symjax.tensor.einsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">einsum()</span></code></a>.
In addition to the original NumPy arguments listed below, also supports
<code class="docutils literal notranslate"><span class="pre">precision</span></code> for extra control over matrix-multiplication precision
on supported devices. See <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.lax.dot()</span></code> for details.</p>
<p>Original docstring below.</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>einsum(subscripts, <a href="#id57"><span class="problematic" id="id58">*</span></a>operands, out=None, dtype=None, order=’K’,</dt><dd><p>casting=’safe’, optimize=False)</p>
</dd>
</dl>
<p>Using the Einstein summation convention, many common multi-dimensional
array operations can be represented in a simple fashion.  This function
provides a way to compute such summations. The best way to understand this
function is to try the examples below, which show how many common NumPy
functions can be implemented as calls to <cite>einsum</cite>.</p>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>The calculation based on the Einstein summation convention.</p>
</dd>
</dl>
<p>einsum_path, dot, inner, outer, tensordot, linalg.multi_dot</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.6.0.</span></p>
</div>
<p>The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Repeated subscripts labels in one operand take the diagonal.  For example,
<code class="docutils literal notranslate"><span class="pre">np.einsum('ii',</span> <span class="pre">a)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">np.trace(a)</span></code>.</p>
<p>Whenever a label is repeated, it is summed, so <code class="docutils literal notranslate"><span class="pre">np.einsum('i,i',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">np.inner(a,b)</span></code>.  If a label appears only once,
it is not summed, so <code class="docutils literal notranslate"><span class="pre">np.einsum('i',</span> <span class="pre">a)</span></code> produces a view of <code class="docutils literal notranslate"><span class="pre">a</span></code>
with no changes.</p>
<p>The order of labels in the output is by default alphabetical.  This
means that <code class="docutils literal notranslate"><span class="pre">np.einsum('ij',</span> <span class="pre">a)</span></code> doesn’t affect a 2D array, while
<code class="docutils literal notranslate"><span class="pre">np.einsum('ji',</span> <span class="pre">a)</span></code> takes its transpose.</p>
<p>The output can be controlled by specifying output subscript labels
as well.  This specifies the label order, and allows summing to
be disallowed or forced when desired.  The call <code class="docutils literal notranslate"><span class="pre">np.einsum('i-&gt;',</span> <span class="pre">a)</span></code>
is like <code class="docutils literal notranslate"><span class="pre">np.sum(a,</span> <span class="pre">axis=-1)</span></code>, and <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code>
is like <code class="docutils literal notranslate"><span class="pre">np.diag(a)</span></code>.  The difference is that <cite>einsum</cite> does not
allow broadcasting by default.</p>
<p>To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like <code class="docutils literal notranslate"><span class="pre">np.einsum('...ii-&gt;...i',</span> <span class="pre">a)</span></code>.
To take the trace along the first and last axes,
you can do <code class="docutils literal notranslate"><span class="pre">np.einsum('i...i',</span> <span class="pre">a)</span></code>, or to do a matrix-matrix
product with the left-most indices instead of rightmost, you can do
<code class="docutils literal notranslate"><span class="pre">np.einsum('ij...,jk...-&gt;ik...',</span> <span class="pre">a,</span> <span class="pre">b)</span></code>.</p>
<p>When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as <code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code>
produces a view.</p>
<p>An alternative way to provide the subscripts and operands is as
<code class="docutils literal notranslate"><span class="pre">einsum(op0,</span> <span class="pre">sublist0,</span> <span class="pre">op1,</span> <span class="pre">sublist1,</span> <span class="pre">...,</span> <span class="pre">[sublistout])</span></code>. The examples
below have corresponding <cite>einsum</cite> calls with the two parameter methods.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<p>Views returned from einsum are now writeable whenever the input array
is writeable. For example, <code class="docutils literal notranslate"><span class="pre">np.einsum('ijk...-&gt;kji...',</span> <span class="pre">a)</span></code> will now
have the same effect as <code class="docutils literal notranslate"><span class="pre">np.swapaxes(a,</span> <span class="pre">0,</span> <span class="pre">2)</span></code> and
<code class="docutils literal notranslate"><span class="pre">np.einsum('ii-&gt;i',</span> <span class="pre">a)</span></code> will return a writeable view of the diagonal
of a 2D array.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>Added the <code class="docutils literal notranslate"><span class="pre">optimize</span></code> argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">np.einsum_path</span></code> for more details.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">60</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 0,  6, 12, 18, 24])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...j,j&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([ 30,  80, 130, 180, 230])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji&#39;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[0, 3],</span>
<span class="go">       [1, 4],</span>
<span class="go">       [2, 5]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;..., ...&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;,ij&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="go">array([[ 0,  3,  6],</span>
<span class="go">       [ 9, 12, 15]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,i&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,j&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [0, 2, 4, 6, 8]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i...-&gt;...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([50, 55, 60, 65, 70])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="bp">Ellipsis</span><span class="p">],</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">])</span>
<span class="go">array([50, 55, 60, 65, 70])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([50, 55, 60, 65, 70])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">60.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">24.</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,jil-&gt;kl&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">array([[ 4400.,  4730.],</span>
<span class="go">       [ 4532.,  4874.],</span>
<span class="go">       [ 4664.,  5018.],</span>
<span class="go">       [ 4796.,  5162.],</span>
<span class="go">       [ 4928.,  5306.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,jk-&gt;ij&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,...k-&gt;i...&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;k...,jk&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[10, 28, 46, 64],</span>
<span class="go">       [13, 40, 67, 94]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># since version 1.10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ii-&gt;i&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)[:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.equal">
<code class="sig-name descname">equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 == x2) element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>.
Original docstring below.</p>
<p>equal(x1, x2, /, out=None, <a href="#id59"><span class="problematic" id="id60">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([ True,  True, False])</span>
</pre></div>
</div>
<p>What is compared are values, not types. So an int (1) and an array of
length one can evaluate as True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">array([ True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.empty">
<code class="sig-name descname">empty</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with zeros.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>.
Original docstring below.</p>
<p>zeros(shape, dtype=float, order=’C’)</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="go">array([(0, 0), (0, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.empty_like">
<code class="sig-name descname">empty_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.empty_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type as a given array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros_like" title="symjax.tensor.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros_like" title="symjax.tensor.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Overrides the data type of the result.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array of zeros with the same shape and type as <cite>a</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.empty_like" title="symjax.tensor.empty_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_like()</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ones_like" title="symjax.tensor.ones_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones_like()</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.full_like" title="symjax.tensor.full_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">full_like()</span></code></a></dt><dd><p>Return a new array with shape of input filled with value.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.exp">
<code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the exponential of all elements in the input array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.exp" title="symjax.tensor.exp"><code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.exp" title="symjax.tensor.exp"><code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code></a>.
Original docstring below.</p>
<p>exp(x, /, out=None, <a href="#id61"><span class="problematic" id="id62">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise exponential of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.expm1" title="symjax.tensor.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a></dt><dd><p>Calculate <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> for all elements in the array.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.exp2" title="symjax.tensor.exp2"><code class="xref py py-func docutils literal notranslate"><span class="pre">exp2()</span></code></a></dt><dd><p>Calculate <code class="docutils literal notranslate"><span class="pre">2**x</span></code> for all elements in the array.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The irrational number <code class="docutils literal notranslate"><span class="pre">e</span></code> is also known as Euler’s number.  It is
approximately 2.718281, and is the base of the natural logarithm,
<code class="docutils literal notranslate"><span class="pre">ln</span></code> (this means that, if <span class="math notranslate nohighlight">\(x = \ln y = \log_e y\)</span>,
then <span class="math notranslate nohighlight">\(e^x = y\)</span>. For real input, <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> is always positive.</p>
<p>For complex arguments, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">ib</span></code>, we can write
<span class="math notranslate nohighlight">\(e^x = e^a e^{ib}\)</span>.  The first term, <span class="math notranslate nohighlight">\(e^a\)</span>, is already
known (it is the real argument, described above).  The second term,
<span class="math notranslate nohighlight">\(e^{ib}\)</span>, is <span class="math notranslate nohighlight">\(\cos b + i \sin b\)</span>, a function with
magnitude 1 and a periodic phase.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id63"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, “Exponential function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Exponential_function">http://en.wikipedia.org/wiki/Exponential_function</a></p>
</dd>
<dt class="label" id="id64"><span class="brackets">2</span></dt>
<dd><p>M. Abramovitz and I. A. Stegun, “Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables,” Dover, 1964, p. 69,
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/page_69.htm">http://www.math.sfu.ca/~cbm/aands/page_69.htm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Plot the magnitude and phase of <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> in the complex plane:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># a + ib over complex plane</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">out</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Magnitude of exp(x)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">out</span><span class="p">),</span>
<span class="gp">... </span>           <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;hsv&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase (angle) of exp(x)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.exp2">
<code class="sig-name descname">exp2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#exp2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.exp2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <cite>2**p</cite> for all <cite>p</cite> in the input array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.exp2" title="symjax.tensor.exp2"><code class="xref py py-func docutils literal notranslate"><span class="pre">exp2()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.exp2" title="symjax.tensor.exp2"><code class="xref py py-func docutils literal notranslate"><span class="pre">exp2()</span></code></a>.
Original docstring below.</p>
<p>exp2(x, /, out=None, <a href="#id65"><span class="problematic" id="id66">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Element-wise 2 to the power <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.power" title="symjax.tensor.power"><code class="xref py py-func docutils literal notranslate"><span class="pre">power()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp2</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([ 4.,  8.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.expand_dims">
<code class="sig-name descname">expand_dims</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#expand_dims"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.expand_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the shape of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.expand_dims" title="symjax.tensor.expand_dims"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_dims()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.expand_dims" title="symjax.tensor.expand_dims"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_dims()</span></code></a>.
Original docstring below.</p>
<p>Insert a new axis that will appear at the <cite>axis</cite> position in the expanded
array shape.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Previous to NumPy 1.13.0, neither <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">&lt;</span> <span class="pre">-a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code> nor
<code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">&gt;</span> <span class="pre">a.ndim</span></code> raised errors or put the new axis where documented.
Those axis values are now deprecated and will raise an AxisError in the
future.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>res</strong> – Output array. The number of dimensions is one greater than that of
the input array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.squeeze" title="symjax.tensor.squeeze"><code class="xref py py-func docutils literal notranslate"><span class="pre">squeeze()</span></code></a></dt><dd><p>The inverse operation, removing singleton dimensions</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.reshape" title="symjax.tensor.reshape"><code class="xref py py-func docutils literal notranslate"><span class="pre">reshape()</span></code></a></dt><dd><p>Insert, remove, and combine dimensions, and resize existing ones</p>
</dd>
</dl>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">doc.indexing()</span></code>, <a class="reference internal" href="#symjax.tensor.atleast_1d" title="symjax.tensor.atleast_1d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_1d()</span></code></a>, <a class="reference internal" href="#symjax.tensor.atleast_2d" title="symjax.tensor.atleast_2d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_2d()</span></code></a>, <a class="reference internal" href="#symjax.tensor.atleast_3d" title="symjax.tensor.atleast_3d"><code class="xref py py-func docutils literal notranslate"><span class="pre">atleast_3d()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2,)</span>
</pre></div>
</div>
<p>The following is equivalent to <code class="docutils literal notranslate"><span class="pre">x[np.newaxis,:]</span></code> or <code class="docutils literal notranslate"><span class="pre">x[np.newaxis]</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Equivalent to x[:,np.newaxis]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[1],</span>
<span class="go">       [2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1)</span>
</pre></div>
</div>
<p>Note that some examples may use <code class="docutils literal notranslate"><span class="pre">None</span></code> instead of <code class="docutils literal notranslate"><span class="pre">np.newaxis</span></code>.  These
are the same objects:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.expm1">
<code class="sig-name descname">expm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code> for all elements in the array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.expm1" title="symjax.tensor.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.expm1" title="symjax.tensor.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a>.
Original docstring below.</p>
<p>expm1(x, /, out=None, <a href="#id67"><span class="problematic" id="id68">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Element-wise exponential minus one: <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.log1p" title="symjax.tensor.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code>, the inverse of expm1.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function provides greater precision than <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code>
for small values of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p class="rubric">Examples</p>
<p>The true value of <code class="docutils literal notranslate"><span class="pre">exp(1e-10)</span> <span class="pre">-</span> <span class="pre">1</span></code> is <code class="docutils literal notranslate"><span class="pre">1.00000000005e-10</span></code> to
about 32 significant digits. This example shows the superiority of
expm1 in this case.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span>
<span class="go">1.00000000005e-10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">1e-10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">1.000000082740371e-10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.eye">
<code class="sig-name descname">eye</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">M</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#eye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.eye" title="symjax.tensor.eye"><code class="xref py py-func docutils literal notranslate"><span class="pre">eye()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.eye" title="symjax.tensor.eye"><code class="xref py py-func docutils literal notranslate"><span class="pre">eye()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>I</strong> – An array where all elements are equal to zero, except for the <cite>k</cite>-th
diagonal, whose values are equal to one.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (N,M)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.identity" title="symjax.tensor.identity"><code class="xref py py-func docutils literal notranslate"><span class="pre">identity()</span></code></a></dt><dd><p>(almost) equivalent function</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.diag" title="symjax.tensor.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag()</span></code></a></dt><dd><p>diagonal 2-D array from a 1-D array specified by the user.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 0],</span>
<span class="go">       [0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.fabs">
<code class="sig-name descname">fabs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.fabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the absolute values element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.fabs" title="symjax.tensor.fabs"><code class="xref py py-func docutils literal notranslate"><span class="pre">fabs()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.fabs" title="symjax.tensor.fabs"><code class="xref py py-func docutils literal notranslate"><span class="pre">fabs()</span></code></a>.
Original docstring below.</p>
<p>fabs(x, /, out=None, <a href="#id69"><span class="problematic" id="id70">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>This function returns the absolute values (positive magnitude) of the
data in <cite>x</cite>. Complex values are not handled, use <cite>absolute</cite> to find the
absolute values of complex data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The absolute values of <cite>x</cite>, the returned values are always floats.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.absolute" title="symjax.tensor.absolute"><code class="xref py py-func docutils literal notranslate"><span class="pre">absolute()</span></code></a></dt><dd><p>Absolute values including <cite>complex</cite> types.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">([</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="go">array([ 1.2,  1.2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.flip">
<code class="sig-name descname">flip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#flip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the order of elements in an array along the given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.flip" title="symjax.tensor.flip"><code class="xref py py-func docutils literal notranslate"><span class="pre">flip()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.flip" title="symjax.tensor.flip"><code class="xref py py-func docutils literal notranslate"><span class="pre">flip()</span></code></a>.
Original docstring below.</p>
<p>The shape of the array is preserved, but the elements are reordered.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – A view of <cite>m</cite> with the entries of axis reversed.  Since a view is
returned, this operation is done in constant time.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.flipud" title="symjax.tensor.flipud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipud()</span></code></a></dt><dd><p>Flip an array vertically (axis=0).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.fliplr" title="symjax.tensor.fliplr"><code class="xref py py-func docutils literal notranslate"><span class="pre">fliplr()</span></code></a></dt><dd><p>Flip an array horizontally (axis=1).</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>flip(m, 0) is equivalent to flipud(m).</p>
<p>flip(m, 1) is equivalent to fliplr(m).</p>
<p>flip(m, n) corresponds to <code class="docutils literal notranslate"><span class="pre">m[...,::-1,...]</span></code> with <code class="docutils literal notranslate"><span class="pre">::-1</span></code> at position n.</p>
<p>flip(m) corresponds to <code class="docutils literal notranslate"><span class="pre">m[::-1,::-1,...,::-1]</span></code> with <code class="docutils literal notranslate"><span class="pre">::-1</span></code> at all
positions.</p>
<p>flip(m, (0, 1)) corresponds to <code class="docutils literal notranslate"><span class="pre">m[::-1,::-1,...]</span></code> with <code class="docutils literal notranslate"><span class="pre">::-1</span></code> at
position 0 and position 1.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">array([[[4, 5],</span>
<span class="go">        [6, 7]],</span>
<span class="go">       [[0, 1],</span>
<span class="go">        [2, 3]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[[2, 3],</span>
<span class="go">        [0, 1]],</span>
<span class="go">       [[6, 7],</span>
<span class="go">        [4, 5]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[[7, 6],</span>
<span class="go">        [5, 4]],</span>
<span class="go">       [[3, 2],</span>
<span class="go">        [1, 0]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[5, 4],</span>
<span class="go">        [7, 6]],</span>
<span class="go">       [[1, 0],</span>
<span class="go">        [3, 2]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.fliplr">
<code class="sig-name descname">fliplr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#fliplr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip array in the left/right direction.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.fliplr" title="symjax.tensor.fliplr"><code class="xref py py-func docutils literal notranslate"><span class="pre">fliplr()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.fliplr" title="symjax.tensor.fliplr"><code class="xref py py-func docutils literal notranslate"><span class="pre">fliplr()</span></code></a>.
Original docstring below.</p>
<p>Flip the entries in each row in the left/right direction.
Columns are preserved, but appear in a different order than before.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>f</strong> – A view of <cite>m</cite> with the columns reversed.  Since a view
is returned, this operation is <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.flipud" title="symjax.tensor.flipud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipud()</span></code></a></dt><dd><p>Flip array in the up/down direction.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.rot90" title="symjax.tensor.rot90"><code class="xref py py-func docutils literal notranslate"><span class="pre">rot90()</span></code></a></dt><dd><p>Rotate array counterclockwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  1.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 3.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.flipud">
<code class="sig-name descname">flipud</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#flipud"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip array in the up/down direction.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.flipud" title="symjax.tensor.flipud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipud()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.flipud" title="symjax.tensor.flipud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipud()</span></code></a>.
Original docstring below.</p>
<p>Flip the entries in each column in the up/down direction.
Rows are preserved, but appear in a different order than before.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – A view of <cite>m</cite> with the rows reversed.  Since a view is
returned, this operation is <span class="math notranslate nohighlight">\(\mathcal O(1)\)</span>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.fliplr" title="symjax.tensor.fliplr"><code class="xref py py-func docutils literal notranslate"><span class="pre">fliplr()</span></code></a></dt><dd><p>Flip array in the left/right direction.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.rot90" title="symjax.tensor.rot90"><code class="xref py py-func docutils literal notranslate"><span class="pre">rot90()</span></code></a></dt><dd><p>Rotate array counterclockwise.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">m[::-1,...]</span></code>.
Does not require the array to be two-dimensional.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 0.,  0.,  3.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  3.],</span>
<span class="go">       [ 0.,  2.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">A</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([2, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.float_power">
<code class="sig-name descname">float_power</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.float_power" title="Permalink to this definition">¶</a></dt>
<dd><p>First array elements raised to powers from second array, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.float_power" title="symjax.tensor.float_power"><code class="xref py py-func docutils literal notranslate"><span class="pre">float_power()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.float_power" title="symjax.tensor.float_power"><code class="xref py py-func docutils literal notranslate"><span class="pre">float_power()</span></code></a>.
Original docstring below.</p>
<p>float_power(x1, x2, /, out=None, <a href="#id71"><span class="problematic" id="id72">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Raise each base in <cite>x1</cite> to the positionally-corresponding power in <cite>x2</cite>.
<cite>x1</cite> and <cite>x2</cite> must be broadcastable to the same shape. This differs from
the power function in that integers, float16, and float32  are promoted to
floats with a minimum precision of float64 so that the result is always
inexact.  The intent is that the function will return a usable result for
negative powers and seldom overflow for positive powers.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The bases in <cite>x1</cite> raised to the exponents in <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.power" title="symjax.tensor.power"><code class="xref py py-func docutils literal notranslate"><span class="pre">power()</span></code></a></dt><dd><p>power function that preserves type</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Cube each element in a list.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">float_power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([   0.,    1.,    8.,   27.,   64.,  125.])</span>
</pre></div>
</div>
<p>Raise the bases to different exponents.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">float_power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([  0.,   1.,   8.,  27.,  16.,   5.])</span>
</pre></div>
</div>
<p>The effect of broadcasting.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span>
<span class="go">array([[1, 2, 3, 3, 2, 1],</span>
<span class="go">       [1, 2, 3, 3, 2, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">float_power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([[  0.,   1.,   8.,  27.,  16.,   5.],</span>
<span class="go">       [  0.,   1.,   8.,  27.,  16.,   5.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.floor">
<code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the floor of the input, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.floor" title="symjax.tensor.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.floor" title="symjax.tensor.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a>.
Original docstring below.</p>
<p>floor(x, /, out=None, <a href="#id73"><span class="problematic" id="id74">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The floor of the scalar <cite>x</cite> is the largest integer <cite>i</cite>, such that
<cite>i &lt;= x</cite>.  It is often denoted as <span class="math notranslate nohighlight">\(\lfloor x \rfloor\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The floor of each element in <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.ceil" title="symjax.tensor.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">rint()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Some spreadsheet programs calculate the “floor-towards-zero”, in other
words <code class="docutils literal notranslate"><span class="pre">floor(-2.5)</span> <span class="pre">==</span> <span class="pre">-2</span></code>.  NumPy instead uses the definition of
<cite>floor</cite> where <cite>floor(-2.5) == -3</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([-2., -2., -1.,  0.,  1.,  1.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.floor_divide">
<code class="sig-name descname">floor_divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#floor_divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.floor_divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the largest integer smaller or equal to the division of the inputs.
It is equivalent to the Python <code class="docutils literal notranslate"><span class="pre">//</span></code> operator and pairs with the
Python <code class="docutils literal notranslate"><span class="pre">%</span></code> (<cite>remainder</cite>), function so that <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">*</span> <span class="pre">(a</span> <span class="pre">//</span> <span class="pre">b)</span></code>
up to roundoff.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.floor_divide" title="symjax.tensor.floor_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor_divide()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.floor_divide" title="symjax.tensor.floor_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor_divide()</span></code></a>.
Original docstring below.</p>
<p>floor_divide(x1, x2, /, out=None, <a href="#id75"><span class="problematic" id="id76">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – y = floor(<cite>x1</cite>/<cite>x2</cite>)
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a></dt><dd><p>Remainder complementary to floor_divide.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.divmod" title="symjax.tensor.divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></dt><dd><p>Simultaneous floor division and remainder.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.divide" title="symjax.tensor.divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">divide()</span></code></a></dt><dd><p>Standard division.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.floor" title="symjax.tensor.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a></dt><dd><p>Round a number to the nearest integer toward minus infinity.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ceil" title="symjax.tensor.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">ceil()</span></code></a></dt><dd><p>Round a number to the nearest integer toward infinity.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">],</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.fmod">
<code class="sig-name descname">fmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.fmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element-wise remainder of division.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.fmod" title="symjax.tensor.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">fmod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.fmod" title="symjax.tensor.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">fmod()</span></code></a>.
Original docstring below.</p>
<p>fmod(x1, x2, /, out=None, <a href="#id77"><span class="problematic" id="id78">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>This is the NumPy implementation of the C library function fmod, the
remainder has the same sign as the dividend <cite>x1</cite>. It is equivalent to
the Matlab(TM) <code class="docutils literal notranslate"><span class="pre">rem</span></code> function and should not be confused with the
Python modulus operator <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">%</span> <span class="pre">x2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The remainder of the division of <cite>x1</cite> by <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a></dt><dd><p>Equivalent to the Python <code class="docutils literal notranslate"><span class="pre">%</span></code> operator.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.divide" title="symjax.tensor.divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">divide()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The result of the modulo operation for negative dividend and divisors
is bound by conventions. For <cite>fmod</cite>, the sign of result is the sign of
the dividend, while for <cite>remainder</cite> the sign of the result is the sign
of the divisor. The <cite>fmod</cite> function is equivalent to the Matlab(TM)
<code class="docutils literal notranslate"><span class="pre">rem</span></code> function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([-1,  0, -1,  1,  0,  1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 0, 1, 1, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-3, -2],</span>
<span class="go">       [-1,  0],</span>
<span class="go">       [ 1,  2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([[-1,  0],</span>
<span class="go">       [-1,  0],</span>
<span class="go">       [ 1,  0]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.full">
<code class="sig-name descname">full</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">fill_value</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with <cite>fill_value</cite>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.full" title="symjax.tensor.full"><code class="xref py py-func docutils literal notranslate"><span class="pre">full()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.full" title="symjax.tensor.full"><code class="xref py py-func docutils literal notranslate"><span class="pre">full()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>int</em><em> or </em><em>sequence of ints</em>) – Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p></li>
<li><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – <dl class="simple">
<dt>The desired data-type for the array  The default, <cite>None</cite>, means</dt><dd><p><cite>np.array(fill_value).dtype</cite>.</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array of <cite>fill_value</cite> with the given shape, dtype, and order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.full_like" title="symjax.tensor.full_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">full_like()</span></code></a></dt><dd><p>Return a new array with shape of input filled with value.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.empty" title="symjax.tensor.empty"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty()</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ones" title="symjax.tensor.ones"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones()</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">array([[ inf,  inf],</span>
<span class="go">       [ inf,  inf]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 10],</span>
<span class="go">       [10, 10]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.full_like">
<code class="sig-name descname">full_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">fill_value</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#full_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.full_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full array with the same shape and type as a given array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.full_like" title="symjax.tensor.full_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">full_like()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.full_like" title="symjax.tensor.full_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">full_like()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Overrides the data type of the result.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array of <cite>fill_value</cite> with the same shape and type as <cite>a</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.empty_like" title="symjax.tensor.empty_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_like()</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ones_like" title="symjax.tensor.ones_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones_like()</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.zeros_like" title="symjax.tensor.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.full" title="symjax.tensor.full"><code class="xref py py-func docutils literal notranslate"><span class="pre">full()</span></code></a></dt><dd><p>Return a new array of given shape filled with value.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="go">array([ nan,  nan,  nan,  nan,  nan,  nan])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="go">array([ 0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.gcd">
<code class="sig-name descname">gcd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#gcd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.gcd" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the greatest common divisor of <code class="docutils literal notranslate"><span class="pre">|x1|</span></code> and <code class="docutils literal notranslate"><span class="pre">|x2|</span></code></p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.gcd" title="symjax.tensor.gcd"><code class="xref py py-func docutils literal notranslate"><span class="pre">gcd()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.gcd" title="symjax.tensor.gcd"><code class="xref py py-func docutils literal notranslate"><span class="pre">gcd()</span></code></a>.
Original docstring below.</p>
<p>gcd(x1, x2, /, out=None, <a href="#id79"><span class="problematic" id="id80">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The greatest common divisor of the absolute value of the inputs
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.lcm" title="symjax.tensor.lcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lcm()</span></code></a></dt><dd><p>The lowest common multiple</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">35</span><span class="p">])</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">array([20,  1,  2,  1,  4,  5])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.geomspace">
<code class="sig-name descname">geomspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span></em>, <em class="sig-param"><span class="n">num</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">endpoint</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#geomspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.geomspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return numbers spaced evenly on a log scale (a geometric progression).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.geomspace" title="symjax.tensor.geomspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">geomspace()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.geomspace" title="symjax.tensor.geomspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">geomspace()</span></code></a>.
Original docstring below.</p>
<p>This is similar to <cite>logspace</cite>, but with endpoints specified directly.
Each output sample is a constant multiple of the previous.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em>) – The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>samples</strong> – <cite>num</cite> samples, equally spaced on a log scale.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.logspace" title="symjax.tensor.logspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">logspace()</span></code></a></dt><dd><p>Similar to geomspace, but with endpoints specified using log and base.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.linspace" title="symjax.tensor.linspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">linspace()</span></code></a></dt><dd><p>Similar to geomspace, but with arithmetic instead of geometric progression.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.arange" title="symjax.tensor.arange"><code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code></a></dt><dd><p>Similar to linspace, with the step size specified instead of the number of samples.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If the inputs or dtype are complex, the output will follow a logarithmic
spiral in the complex plane.  (There are an infinite number of spirals
passing through two points; the output will follow the shortest such path.)</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([    1.,    10.,   100.,  1000.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   1.,   10.,  100.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span>
<span class="go">array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])</span>
</pre></div>
</div>
<p>Note that the above may not produce exact integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([  1,   2,   4,   7,  16,  32,  63, 127, 256])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">9</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([  1,   2,   4,   8,  16,  32,  64, 128, 256])</span>
</pre></div>
</div>
<p>Negative, decreasing, and complex inputs are allowed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([ 1000.,   100.,    10.,     1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([-1000.,  -100.,   -10.,    -1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1000</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># Straight line</span>
<span class="go">array([ 0.   +1.j,  0.  +10.j,  0. +100.j,  0.+1000.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Circle</span>
<span class="go">array([-1.00000000+0.j        , -0.70710678+0.70710678j,</span>
<span class="go">        0.00000000+1.j        ,  0.70710678+0.70710678j,</span>
<span class="go">        1.00000000+0.j        ])</span>
</pre></div>
</div>
<p>Graphical illustration of <code class="docutils literal notranslate"><span class="pre">endpoint</span></code> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">semilogx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;0.7&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.greater">
<code class="sig-name descname">greater</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the truth value of (x1 &gt; x2) element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>.
Original docstring below.</p>
<p>greater(x1, x2, /, out=None, <a href="#id81"><span class="problematic" id="id82">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<p>If the inputs are ndarrays, then np.greater is equivalent to ‘&gt;’.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.greater_equal">
<code class="sig-name descname">greater_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.greater_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the truth value of (x1 &gt;= x2) element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>.
Original docstring below.</p>
<p>greater_equal(x1, x2, /, out=None, <a href="#id83"><span class="problematic" id="id84">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool or ndarray of bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([ True, True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.heaviside">
<code class="sig-name descname">heaviside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#heaviside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.heaviside" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Heaviside step function.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.heaviside" title="symjax.tensor.heaviside"><code class="xref py py-func docutils literal notranslate"><span class="pre">heaviside()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.heaviside" title="symjax.tensor.heaviside"><code class="xref py py-func docutils literal notranslate"><span class="pre">heaviside()</span></code></a>.
Original docstring below.</p>
<p>heaviside(x1, x2, /, out=None, <a href="#id85"><span class="problematic" id="id86">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The Heaviside step function is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                      <span class="mi">0</span>   <span class="k">if</span> <span class="n">x1</span> <span class="o">&lt;</span> <span class="mi">0</span>
<span class="n">heaviside</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span>  <span class="n">x2</span>   <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="mi">0</span>
                      <span class="mi">1</span>   <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>where <cite>x2</cite> is often taken to be 0.5, but 0 and 1 are also sometimes used.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The output array, element-wise Heaviside step function of <cite>x1</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<p class="rubric">References</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">heaviside</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">array([ 0. ,  0.5,  1. ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">heaviside</span><span class="p">([</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.hsplit">
<code class="sig-name descname">hsplit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ary</span></em>, <em class="sig-param"><span class="n">indices_or_sections</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.hsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays horizontally (column-wise).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.hsplit" title="symjax.tensor.hsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">hsplit()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LA</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.hstack">
<code class="sig-name descname">hstack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tup</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#hstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.hstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence horizontally (column wise).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a>.
Original docstring below.</p>
<p>This is equivalent to concatenation along the second axis, except for 1-D
arrays where it concatenates along the first axis. Rebuilds arrays divided
by <cite>hsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>stacked</strong> – The array formed by stacking the given arrays.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a></dt><dd><p>Stack arrays in sequence vertically (row wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third axis).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hsplit" title="symjax.tensor.hsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">hsplit()</span></code></a></dt><dd><p>Split array along second axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.block" title="symjax.tensor.block"><code class="xref py py-func docutils literal notranslate"><span class="pre">block()</span></code></a></dt><dd><p>Assemble arrays from blocks.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([1, 2, 3, 2, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.identity">
<code class="sig-name descname">identity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the identity array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.identity" title="symjax.tensor.identity"><code class="xref py py-func docutils literal notranslate"><span class="pre">identity()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.identity" title="symjax.tensor.identity"><code class="xref py py-func docutils literal notranslate"><span class="pre">identity()</span></code></a>.
Original docstring below.</p>
<p>The identity array is a square array with ones on
the main diagonal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Data-type of the output.  Defaults to <code class="docutils literal notranslate"><span class="pre">float</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – <cite>n</cite> x <cite>n</cite> array with its main diagonal set to one,
and all other elements 0.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.imag">
<code class="sig-name descname">imag</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#imag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part of the complex argument.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.imag" title="symjax.tensor.imag"><code class="xref py py-func docutils literal notranslate"><span class="pre">imag()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.imag" title="symjax.tensor.imag"><code class="xref py py-func docutils literal notranslate"><span class="pre">imag()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The imaginary component of the complex argument. If <cite>val</cite> is real,
the type of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex
elements, the returned type is float.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.real" title="symjax.tensor.real"><code class="xref py py-func docutils literal notranslate"><span class="pre">real()</span></code></a>, <a class="reference internal" href="#symjax.tensor.angle" title="symjax.tensor.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">real_if_close()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span>
<span class="go">array([ 2.,  4.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 1. +8.j,  3.+10.j,  5.+12.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.inner">
<code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">precision</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of two arrays.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.inner" title="symjax.tensor.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">inner()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.inner" title="symjax.tensor.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">inner()</span></code></a>.
In addition to the original NumPy arguments listed below, also supports
<code class="docutils literal notranslate"><span class="pre">precision</span></code> for extra control over matrix-multiplication precision
on supported devices. See <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.lax.dot()</span></code> for details.</p>
<p>Original docstring below.</p>
<p>inner(a, b)</p>
<blockquote>
<div><blockquote>
<div><p>Ordinary inner product of vectors for 1-D arrays (without complex
conjugation), in higher dimensions a sum product over the last axes.</p>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p><cite>out.shape = a.shape[:-1] + b.shape[:-1]</cite></p>
</dd>
</dl>
<dl class="simple">
<dt>ValueError</dt><dd><p>If the last dimension of <cite>a</cite> and <cite>b</cite> has different size.</p>
</dd>
</dl>
<p>tensordot : Sum products over arbitrary axes.
dot : Generalised matrix product, using second last dimension of <cite>b</cite>.
einsum : Einstein summation convention.</p>
<p>For vectors (1-D arrays) it computes the ordinary inner-product:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[:]</span><span class="o">*</span><span class="n">b</span><span class="p">[:])</span>
</pre></div>
</div>
<p>More generally, if <cite>ndim(a) = r &gt; 0</cite> and <cite>ndim(b) = s &gt; 0</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>or explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ir</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">js</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
     <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">ir</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">j0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">js</span><span class="o">-</span><span class="mi">1</span><span class="p">,:])</span>
</pre></div>
</div>
<p>In addition <cite>a</cite> or <cite>b</cite> may be scalars, in which case:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span>
</pre></div>
</div>
<p>Ordinary inner product for vectors:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>A multidimensional example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[ 14,  38,  62],</span>
<span class="go">       [ 86, 110, 134]])</span>
</pre></div>
</div>
<p>An example where <cite>b</cite> is a scalar:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">array([[ 7.,  0.],</span>
<span class="go">       [ 0.,  7.]])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.isclose">
<code class="sig-name descname">isclose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">rtol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">atol</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">equal_nan</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#isclose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.isclose" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Returns a boolean array where two arrays are element-wise equal within a</dt><dd><p>tolerance.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isclose" title="symjax.tensor.isclose"><code class="xref py py-func docutils literal notranslate"><span class="pre">isclose()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isclose" title="symjax.tensor.isclose"><code class="xref py py-func docutils literal notranslate"><span class="pre">isclose()</span></code></a>.
Original docstring below.</p>
<p>The tolerance values are positive, typically very small numbers.  The
relative difference (<cite>rtol</cite> * abs(<cite>b</cite>)) and the absolute difference
<cite>atol</cite> are added together to compare against the absolute difference
between <cite>a</cite> and <cite>b</cite>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default <cite>atol</cite> is not appropriate for comparing numbers
that are much smaller than one (see Notes).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Returns a boolean array of where <cite>a</cite> and <cite>b</cite> are equal within the
given tolerance. If both <cite>a</cite> and <cite>b</cite> are scalars, returns a single
boolean value.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.allclose" title="symjax.tensor.allclose"><code class="xref py py-func docutils literal notranslate"><span class="pre">allclose()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.</p>
<blockquote>
<div><p>absolute(<cite>a</cite> - <cite>b</cite>) &lt;= (<cite>atol</cite> + <cite>rtol</cite> * absolute(<cite>b</cite>))</p>
</div></blockquote>
<p>Unlike the built-in <cite>math.isclose</cite>, the above equation is not symmetric
in <cite>a</cite> and <cite>b</cite> – it assumes <cite>b</cite> is the reference value – so that
<cite>isclose(a, b)</cite> might be different from <cite>isclose(b, a)</cite>. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
<cite>atol</cite> should be carefully selected for the use case at hand. A zero value
for <cite>atol</cite> will result in <cite>False</cite> if either <cite>a</cite> or <cite>b</cite> is zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">])</span>
<span class="go">array([True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.00001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">array([True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e10</span><span class="p">,</span><span class="mf">1e-8</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0001e10</span><span class="p">,</span><span class="mf">1e-9</span><span class="p">])</span>
<span class="go">array([False, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([True, False])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([True, True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="go">array([ True, False], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-100</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([False, False], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
<span class="go">array([ True,  True], dtype=bool)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">([</span><span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e-20</span><span class="p">,</span> <span class="mf">0.999999e-10</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="go">array([False,  True], dtype=bool)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.iscomplex">
<code class="sig-name descname">iscomplex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#iscomplex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.iscomplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is complex.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.iscomplex" title="symjax.tensor.iscomplex"><code class="xref py py-func docutils literal notranslate"><span class="pre">iscomplex()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.iscomplex" title="symjax.tensor.iscomplex"><code class="xref py py-func docutils literal notranslate"><span class="pre">iscomplex()</span></code></a>.
Original docstring below.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if
the input type is complex.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of bools</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.isreal" title="symjax.tensor.isreal"><code class="xref py py-func docutils literal notranslate"><span class="pre">isreal()</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">iscomplexobj()</span></code></dt><dd><p>Return True if x is a complex type or an array of complex numbers.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([ True, False, False, False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.isfinite">
<code class="sig-name descname">isfinite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#isfinite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.isfinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a>.
Original docstring below.</p>
<p>isfinite(x, /, out=None, <a href="#id87"><span class="problematic" id="id88">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The result is returned as a boolean array.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is not positive infinity, negative infinity,
or NaN; false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray, bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.isinf" title="symjax.tensor.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">isneginf()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">isposinf()</span></code>, <a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <cite>x</cite> is a scalar input, or if
first and second arguments have different shapes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="go">array([False,  True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([0, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0, 1, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.isinf">
<code class="sig-name descname">isinf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#isinf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.isinf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for positive or negative infinity.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isinf" title="symjax.tensor.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isinf" title="symjax.tensor.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a>.
Original docstring below.</p>
<p>isinf(x, /, out=None, <a href="#id89"><span class="problematic" id="id90">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns a boolean array of the same shape as <cite>x</cite>, True where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span>
<span class="pre">+/-inf</span></code>, otherwise False.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is positive or negative infinity, false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool (scalar) or boolean ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">isneginf()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">isposinf()</span></code>, <a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a>, <a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is supplied when the first
argument is a scalar, or if the first and second arguments have
different shapes.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ True,  True, False, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([1, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([1, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.isnan">
<code class="sig-name descname">isnan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#isnan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for NaN and return result as a boolean array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a>.
Original docstring below.</p>
<p>isnan(x, /, out=None, <a href="#id91"><span class="problematic" id="id92">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is NaN, false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.isinf" title="symjax.tensor.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">isneginf()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">isposinf()</span></code>, <a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">isnat()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="go">array([ True, False, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.isreal">
<code class="sig-name descname">isreal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#isreal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.isreal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool array, where True if input element is real.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isreal" title="symjax.tensor.isreal"><code class="xref py py-func docutils literal notranslate"><span class="pre">isreal()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isreal" title="symjax.tensor.isreal"><code class="xref py py-func docutils literal notranslate"><span class="pre">isreal()</span></code></a>.
Original docstring below.</p>
<p>If element has complex type with zero complex part, the return value
for that element is True.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Boolean array of same shape as <cite>x</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray, bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.iscomplex" title="symjax.tensor.iscomplex"><code class="xref py py-func docutils literal notranslate"><span class="pre">iscomplex()</span></code></a></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">isrealobj()</span></code></dt><dd><p>Return True if x is not a complex type.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">0</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="n">j</span><span class="p">])</span>
<span class="go">array([False,  True,  True,  True,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.isscalar">
<code class="sig-name descname">isscalar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#isscalar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.isscalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the type of <cite>num</cite> is a scalar type.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isscalar" title="symjax.tensor.isscalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">isscalar()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.isscalar" title="symjax.tensor.isscalar"><code class="xref py py-func docutils literal notranslate"><span class="pre">isscalar()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>val</strong> – True if <cite>num</cite> is a scalar type, False if it is not.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="mf">3.1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">([</span><span class="mf">3.1</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>NumPy supports PEP 3141 numbers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isscalar</span><span class="p">(</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isscalar</span><span class="p">(</span><span class="n">Number</span><span class="p">())</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.ix_">
<code class="sig-name descname">ix_</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#ix_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.ix_" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an open mesh from multiple sequences.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ix_" title="symjax.tensor.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ix_" title="symjax.tensor.ix_"><code class="xref py py-func docutils literal notranslate"><span class="pre">ix_()</span></code></a>.
Original docstring below.</p>
<p>This function takes N 1-D sequences and returns N outputs with N
dimensions each, such that the shape is 1 in all but one dimension
and the dimension with the non-unit shape value cycles through all
N dimensions.</p>
<p>Using <cite>ix_</cite> one can quickly construct index arrays that will index
the cross product. <code class="docutils literal notranslate"><span class="pre">a[np.ix_([1,3],[2,5])]</span></code> returns the array
<code class="docutils literal notranslate"><span class="pre">[[a[1,2]</span> <span class="pre">a[1,5]],</span> <span class="pre">[a[3,2]</span> <span class="pre">a[3,5]]]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> (<em>1-D sequences</em>) – Each sequence should be of integer or boolean type.
Boolean sequences will be interpreted as boolean masks for the
corresponding dimension (equivalent to passing in
<code class="docutils literal notranslate"><span class="pre">np.nonzero(boolean_sequence)</span></code>).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – N arrays with N dimensions each, with N the number of input
sequences. Together these arrays form an open mesh.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple of ndarrays</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">ogrid()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">mgrid()</span></code>, <a class="reference internal" href="#symjax.tensor.meshgrid" title="symjax.tensor.meshgrid"><code class="xref py py-func docutils literal notranslate"><span class="pre">meshgrid()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span>
<span class="go">(array([[0],</span>
<span class="go">       [1]]), array([[2, 4]]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ixgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((2, 1), (1, 2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ixgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ixgrid</span><span class="p">]</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [7, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.kron">
<code class="sig-name descname">kron</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#kron"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Kronecker product of two arrays.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.kron" title="symjax.tensor.kron"><code class="xref py py-func docutils literal notranslate"><span class="pre">kron()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.kron" title="symjax.tensor.kron"><code class="xref py py-func docutils literal notranslate"><span class="pre">kron()</span></code></a>.
Original docstring below.</p>
<p>Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.outer" title="symjax.tensor.outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">outer()</span></code></a></dt><dd><p>The outer product</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The function assumes that the number of dimensions of <cite>a</cite> and <cite>b</cite>
are the same, if necessary prepending the smallest with ones.
If <cite>a.shape = (r0,r1,..,rN)</cite> and <cite>b.shape = (s0,s1,…,sN)</cite>,
the Kronecker product has shape <cite>(r0*s0, r1*s1, …, rN*SN)</cite>.
The elements are products of elements from <cite>a</cite> and <cite>b</cite>, organized
explicitly by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)[</span><span class="n">k0</span><span class="p">,</span><span class="n">k1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">kN</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">iN</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j0</span><span class="p">,</span><span class="n">j1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">jN</span><span class="p">]</span>
</pre></div>
</div>
<p>where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">kt</span> <span class="o">=</span> <span class="n">it</span> <span class="o">*</span> <span class="n">st</span> <span class="o">+</span> <span class="n">jt</span><span class="p">,</span>  <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">N</span>
</pre></div>
</div>
<p>In the common 2-D case (N=1), the block structure can be visualized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>   <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>  <span class="o">...</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span>  <span class="p">],</span>
 <span class="p">[</span>  <span class="o">...</span>                              <span class="o">...</span>   <span class="p">],</span>
 <span class="p">[</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span>  <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span> <span class="p">]]</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="go">array([  5,   6,   7,  50,  60,  70, 500, 600, 700])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">])</span>
<span class="go">array([  5,  50, 500,   6,  60, 600,   7,  70, 700])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">array([[ 1.,  1.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.],</span>
<span class="go">       [ 0.,  0.,  1.,  1.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 10, 6, 20)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">J</span>             <span class="c1"># extend to ndim=4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="n">K</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">I</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="n">J</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.lcm">
<code class="sig-name descname">lcm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#lcm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.lcm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lowest common multiple of <code class="docutils literal notranslate"><span class="pre">|x1|</span></code> and <code class="docutils literal notranslate"><span class="pre">|x2|</span></code></p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.lcm" title="symjax.tensor.lcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lcm()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.lcm" title="symjax.tensor.lcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">lcm()</span></code></a>.
Original docstring below.</p>
<p>lcm(x1, x2, /, out=None, <a href="#id93"><span class="problematic" id="id94">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The lowest common multiple of the absolute value of the inputs
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.gcd" title="symjax.tensor.gcd"><code class="xref py py-func docutils literal notranslate"><span class="pre">gcd()</span></code></a></dt><dd><p>The greatest common divisor</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="go">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="o">.</span><span class="n">reduce</span><span class="p">([</span><span class="mi">40</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="go">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="mi">20</span><span class="p">)</span>
<span class="go">array([ 0, 20, 20, 60, 20, 20])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.left_shift">
<code class="sig-name descname">left_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.left_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the bits of an integer to the left.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.left_shift" title="symjax.tensor.left_shift"><code class="xref py py-func docutils literal notranslate"><span class="pre">left_shift()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.left_shift" title="symjax.tensor.left_shift"><code class="xref py py-func docutils literal notranslate"><span class="pre">left_shift()</span></code></a>.
Original docstring below.</p>
<p>left_shift(x1, x2, /, out=None, <a href="#id95"><span class="problematic" id="id96">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Bits are shifted to the left by appending <cite>x2</cite> 0s at the right of <cite>x1</cite>.
Since the internal representation of numbers is in binary format, this
operation is equivalent to multiplying <cite>x1</cite> by <code class="docutils literal notranslate"><span class="pre">2**x2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Return <cite>x1</cite> with bits shifted <cite>x2</cite> times to the left.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array of integer type</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">right_shift()</span></code></dt><dd><p>Shift the bits of an integer to the right.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">binary_repr()</span></code></dt><dd><p>Return the binary representation of the input number as a string.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">&#39;101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">binary_repr</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">&#39;10100&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">array([10, 20, 40])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.less">
<code class="sig-name descname">less</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.less" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the truth value of (x1 &lt; x2) element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>.
Original docstring below.</p>
<p>less(x1, x2, /, out=None, <a href="#id97"><span class="problematic" id="id98">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.less_equal">
<code class="sig-name descname">less_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the truth value of (x1 =&lt; x2) element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a>.
Original docstring below.</p>
<p>less_equal(x1, x2, /, out=None, <a href="#id99"><span class="problematic" id="id100">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>, <a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([False,  True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.linspace">
<code class="sig-name descname">linspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span></em>, <em class="sig-param"><span class="n">num</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">endpoint</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">retstep</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#linspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.linspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return evenly spaced numbers over a specified interval.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.linspace" title="symjax.tensor.linspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">linspace()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.linspace" title="symjax.tensor.linspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">linspace()</span></code></a>.
Original docstring below.</p>
<p>Returns <cite>num</cite> evenly spaced samples, calculated over the
interval [<cite>start</cite>, <cite>stop</cite>].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul>
<li><p><strong>samples</strong> (<em>ndarray</em>) – There are <cite>num</cite> equally spaced samples in the closed interval
<code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">stop]</span></code> or the half-open interval <code class="docutils literal notranslate"><span class="pre">[start,</span> <span class="pre">stop)</span></code>
(depending on whether <cite>endpoint</cite> is True or False).</p></li>
<li><p><strong>step</strong> (<em>float, optional</em>) – Only returned if <cite>retstep</cite> is True</p>
<p>Size of spacing between samples.</p>
</li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.arange" title="symjax.tensor.arange"><code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code></a></dt><dd><p>Similar to <cite>linspace</cite>, but uses a step size (instead of the number of samples).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.logspace" title="symjax.tensor.logspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">logspace()</span></code></a></dt><dd><p>Samples uniformly distributed in log space.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 2. ,  2.2,  2.4,  2.6,  2.8])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)</span>
</pre></div>
</div>
<p>Graphical illustration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(-0.5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.log">
<code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Natural logarithm, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log" title="symjax.tensor.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">log()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log" title="symjax.tensor.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">log()</span></code></a>.
Original docstring below.</p>
<p>log(x, /, out=None, <a href="#id101"><span class="problematic" id="id102">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The natural logarithm <cite>log</cite> is the inverse of the exponential function,
so that <cite>log(exp(x)) = x</cite>. The natural logarithm is logarithm in base
<cite>e</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The natural logarithm of <cite>x</cite>, element-wise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.log10" title="symjax.tensor.log10"><code class="xref py py-func docutils literal notranslate"><span class="pre">log10()</span></code></a>, <a class="reference internal" href="#symjax.tensor.log2" title="symjax.tensor.log2"><code class="xref py py-func docutils literal notranslate"><span class="pre">log2()</span></code></a>, <a class="reference internal" href="#symjax.tensor.log1p" title="symjax.tensor.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">emath.log()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>exp(z) = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log</cite> always returns real output. For
each value that cannot be expressed as a real number or infinity, it
yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 0]</cite> and is continuous from above on it. <cite>log</cite>
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id103"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 67. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id104"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Logarithm”. <a class="reference external" href="http://en.wikipedia.org/wiki/Logarithm">http://en.wikipedia.org/wiki/Logarithm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">array([  0.,   1.,   2., -Inf])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.log10">
<code class="sig-name descname">log10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#log10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the base 10 logarithm of the input array, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log10" title="symjax.tensor.log10"><code class="xref py py-func docutils literal notranslate"><span class="pre">log10()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log10" title="symjax.tensor.log10"><code class="xref py py-func docutils literal notranslate"><span class="pre">log10()</span></code></a>.
Original docstring below.</p>
<p>log10(x, /, out=None, <a href="#id105"><span class="problematic" id="id106">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The logarithm to the base 10 of <cite>x</cite>, element-wise. NaNs are
returned where x is negative.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">emath.log10()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>10**z = x</cite>. The convention is to return the
<cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log10</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log10</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 0]</cite> and is continuous from above on it.
<cite>log10</cite> handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id107"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 67. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id108"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Logarithm”. <a class="reference external" href="http://en.wikipedia.org/wiki/Logarithm">http://en.wikipedia.org/wiki/Logarithm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">([</span><span class="mf">1e-15</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="p">])</span>
<span class="go">array([-15.,  NaN])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.log1p">
<code class="sig-name descname">log1p</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.log1p" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the natural logarithm of one plus the input array, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log1p" title="symjax.tensor.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log1p" title="symjax.tensor.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a>.
Original docstring below.</p>
<p>log1p(x, /, out=None, <a href="#id109"><span class="problematic" id="id110">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">log(1</span> <span class="pre">+</span> <span class="pre">x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Natural logarithm of <cite>1 + x</cite>, element-wise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.expm1" title="symjax.tensor.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">-</span> <span class="pre">1</span></code>, the inverse of <cite>log1p</cite>.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For real-valued input, <cite>log1p</cite> is accurate also for <cite>x</cite> so small
that <cite>1 + x == 1</cite> in floating-point accuracy.</p>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>exp(z) = 1 + x</cite>. The convention is to return
the <cite>z</cite> whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log1p</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log1p</cite> is a complex analytical function that
has a branch cut <cite>[-inf, -1]</cite> and is continuous from above on it.
<cite>log1p</cite> handles the floating-point negative zero as an infinitesimal
negative number, conforming to the C99 standard.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id111"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
10th printing, 1964, pp. 67. <a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id112"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Logarithm”. <a class="reference external" href="http://en.wikipedia.org/wiki/Logarithm">http://en.wikipedia.org/wiki/Logarithm</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="mf">1e-99</span><span class="p">)</span>
<span class="go">1e-99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1e-99</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.log2">
<code class="sig-name descname">log2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#log2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Base-2 logarithm of <cite>x</cite>.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log2" title="symjax.tensor.log2"><code class="xref py py-func docutils literal notranslate"><span class="pre">log2()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.log2" title="symjax.tensor.log2"><code class="xref py py-func docutils literal notranslate"><span class="pre">log2()</span></code></a>.
Original docstring below.</p>
<p>log2(x, /, out=None, <a href="#id113"><span class="problematic" id="id114">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Base-2 logarithm of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.log" title="symjax.tensor.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">log()</span></code></a>, <a class="reference internal" href="#symjax.tensor.log10" title="symjax.tensor.log10"><code class="xref py py-func docutils literal notranslate"><span class="pre">log10()</span></code></a>, <a class="reference internal" href="#symjax.tensor.log1p" title="symjax.tensor.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">emath.log2()</span></code></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>Logarithm is a multivalued function: for each <cite>x</cite> there is an infinite
number of <cite>z</cite> such that <cite>2**z = x</cite>. The convention is to return the <cite>z</cite>
whose imaginary part lies in <cite>[-pi, pi]</cite>.</p>
<p>For real-valued input data types, <cite>log2</cite> always returns real output.
For each value that cannot be expressed as a real number or infinity,
it yields <code class="docutils literal notranslate"><span class="pre">nan</span></code> and sets the <cite>invalid</cite> floating point error flag.</p>
<p>For complex-valued input, <cite>log2</cite> is a complex analytical function that
has a branch cut <cite>[-inf, 0]</cite> and is continuous from above on it. <cite>log2</cite>
handles the floating-point negative zero as an infinitesimal negative
number, conforming to the C99 standard.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([-Inf,   0.,   1.,   4.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="o">+</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mf">0.</span><span class="n">j</span><span class="p">,</span> <span class="mf">4.</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
<span class="go">array([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.logical_and">
<code class="sig-name descname">logical_and</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.logical_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of x1 AND x2 element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_and" title="symjax.tensor.logical_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_and()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_and" title="symjax.tensor.logical_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_and()</span></code></a>.
Original docstring below.</p>
<p>logical_and(x1, x2, /, out=None, <a href="#id115"><span class="problematic" id="id116">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Boolean result with the same shape as <cite>x1</cite> and <cite>x2</cite> of the logical
AND operation on corresponding elements of <cite>x1</cite> and <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_or" title="symjax.tensor.logical_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_or()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_not" title="symjax.tensor.logical_not"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_not()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_xor" title="symjax.tensor.logical_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_and" title="symjax.tensor.bitwise_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_and()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="go">array([False, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([False, False,  True,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.logical_not">
<code class="sig-name descname">logical_not</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.logical_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of NOT x element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_not" title="symjax.tensor.logical_not"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_not()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_not" title="symjax.tensor.logical_not"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_not()</span></code></a>.
Original docstring below.</p>
<p>logical_not(x, /, out=None, <a href="#id117"><span class="problematic" id="id118">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Boolean result with the same shape as <cite>x</cite> of the NOT operation
on elements of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool or ndarray of bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_and" title="symjax.tensor.logical_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_or" title="symjax.tensor.logical_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_or()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_xor" title="symjax.tensor.logical_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_xor()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([False,  True,  True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([False, False, False,  True,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.logical_or">
<code class="sig-name descname">logical_or</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.logical_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of x1 OR x2 element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_or" title="symjax.tensor.logical_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_or()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_or" title="symjax.tensor.logical_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_or()</span></code></a>.
Original docstring below.</p>
<p>logical_or(x1, x2, /, out=None, <a href="#id119"><span class="problematic" id="id120">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Boolean result with the same shape as <cite>x1</cite> and <cite>x2</cite> of the logical
OR operation on elements of <cite>x1</cite> and <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_and" title="symjax.tensor.logical_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_not" title="symjax.tensor.logical_not"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_not()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_xor" title="symjax.tensor.logical_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_or" title="symjax.tensor.bitwise_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_or()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="go">array([ True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([ True, False, False, False,  True])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.logical_xor">
<code class="sig-name descname">logical_xor</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.logical_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of x1 XOR x2, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_xor" title="symjax.tensor.logical_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logical_xor" title="symjax.tensor.logical_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_xor()</span></code></a>.
Original docstring below.</p>
<p>logical_xor(x1, x2, /, out=None, <a href="#id121"><span class="problematic" id="id122">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Boolean result of the logical XOR operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by whether or not
broadcasting of one or both arrays was required.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool or ndarray of bool</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.logical_and" title="symjax.tensor.logical_and"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_and()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_or" title="symjax.tensor.logical_or"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_or()</span></code></a>, <a class="reference internal" href="#symjax.tensor.logical_not" title="symjax.tensor.logical_not"><code class="xref py py-func docutils literal notranslate"><span class="pre">logical_not()</span></code></a>, <a class="reference internal" href="#symjax.tensor.bitwise_xor" title="symjax.tensor.bitwise_xor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bitwise_xor()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
<span class="go">array([False,  True,  True, False])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([ True, False, False, False,  True])</span>
</pre></div>
</div>
<p>Simple example showing support of broadcasting</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([[ True, False],</span>
<span class="go">       [False,  True]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.logspace">
<code class="sig-name descname">logspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span></em>, <em class="sig-param"><span class="n">num</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">endpoint</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">base</span><span class="o">=</span><span class="default_value">10.0</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#logspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.logspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return numbers spaced evenly on a log scale.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logspace" title="symjax.tensor.logspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">logspace()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.logspace" title="symjax.tensor.logspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">logspace()</span></code></a>.
Original docstring below.</p>
<p>In linear space, the sequence starts at <code class="docutils literal notranslate"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">start</span></code>
(<cite>base</cite> to the power of <cite>start</cite>) and ends with <code class="docutils literal notranslate"><span class="pre">base</span> <span class="pre">**</span> <span class="pre">stop</span></code>
(see <cite>endpoint</cite> below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em>) – The type of the output array.  If <cite>dtype</cite> is not given, infer the data
type from the other input arguments.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>samples</strong> – <cite>num</cite> samples, equally spaced on a log scale.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.arange" title="symjax.tensor.arange"><code class="xref py py-func docutils literal notranslate"><span class="pre">arange()</span></code></a></dt><dd><p>Similar to linspace, with the step size specified instead of the number of samples. Note that, when used with a float endpoint, the endpoint may or may not be included.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.linspace" title="symjax.tensor.linspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">linspace()</span></code></a></dt><dd><p>Similar to logspace, but with the samples uniformly distributed in linear space, instead of log space.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.geomspace" title="symjax.tensor.geomspace"><code class="xref py py-func docutils literal notranslate"><span class="pre">geomspace()</span></code></a></dt><dd><p>Similar to logspace, but with endpoints specified directly.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Logspace is equivalent to the code</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">)</span>
<span class="gp">... </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="gp">... </span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([  100.        ,   215.443469  ,   464.15888336,  1000.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([ 100.        ,  177.827941  ,  316.22776602,  562.34132519])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go">array([ 4.        ,  5.0396842 ,  6.34960421,  8.        ])</span>
</pre></div>
</div>
<p>Graphical illustration:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">(-0.5, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.matmul">
<code class="sig-name descname">matmul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">precision</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#matmul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix product of two arrays.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.matmul" title="symjax.tensor.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.matmul" title="symjax.tensor.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code></a>.
In addition to the original NumPy arguments listed below, also supports
<code class="docutils literal notranslate"><span class="pre">precision</span></code> for extra control over matrix-multiplication precision
on supported devices. See <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.lax.dot()</span></code> for details.</p>
<p>Original docstring below.</p>
<p>matmul(a, b, out=None)</p>
<blockquote>
<div><blockquote>
<div><p>The behavior depends on the arguments in the following way.</p>
<ul class="simple">
<li><p>If both arguments are 2-D they are multiplied like conventional
matrices.</p></li>
<li><p>If either argument is N-D, N &gt; 2, it is treated as a stack of
matrices residing in the last two indexes and broadcast accordingly.</p></li>
<li><p>If the first argument is 1-D, it is promoted to a matrix by
prepending a 1 to its dimensions. After matrix multiplication
the prepended 1 is removed.</p></li>
<li><p>If the second argument is 1-D, it is promoted to a matrix by
appending a 1 to its dimensions. After matrix multiplication
the appended 1 is removed.</p></li>
</ul>
<p>Multiplication by a scalar is not allowed, use <code class="docutils literal notranslate"><span class="pre">*</span></code> instead. Note that
multiplying a stack of matrices with a vector will result in a stack of
vectors, but matmul will not recognize it as such.</p>
<p><code class="docutils literal notranslate"><span class="pre">matmul</span></code> differs from <code class="docutils literal notranslate"><span class="pre">dot</span></code> in two important ways.</p>
<ul class="simple">
<li><p>Multiplication by scalars is not allowed.</p></li>
<li><p>Stacks of matrices are broadcast together as if the matrices
were elements.</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is preliminary and included in NumPy 1.10.0 for testing
and documentation. Its semantics will not change, but the number and
order of the optional arguments will.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
1-D arrays then a scalar is returned; otherwise an array is
returned.  If <cite>out</cite> is given, then it is returned.</p>
</dd>
</dl>
<dl>
<dt>ValueError</dt><dd><p>If the last dimension of <cite>a</cite> is not the same size as
the second-to-last dimension of <cite>b</cite>.</p>
<p>If scalar value is passed.</p>
</dd>
</dl>
<p>vdot : Complex-conjugating dot product.
tensordot : Sum products over arbitrary axes.
einsum : Einstein summation convention.
dot : alternative matrix product with different broadcasting rules.</p>
<p>The matmul function implements the semantics of the <cite>&#64;</cite> operator introduced
in Python 3.5 following PEP465.</p>
<p>For 2-D arrays it is the matrix product:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[4, 1],</span>
<span class="go">       [2, 2]])</span>
</pre></div>
</div>
<p>For 2-D mixed with 1-D, the result is the usual.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">array([1, 2])</span>
</pre></div>
</div>
<p>Broadcasting is conventional for stacks of arrays</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="go">98</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">98</span>
</pre></div>
</div>
<p>Vector, vector returns the scalar inner product, but neither argument
is complex-conjugated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">([</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="n">j</span><span class="p">])</span>
<span class="go">(-13+0j)</span>
</pre></div>
</div>
<p>Scalar multiplication raises an error.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Scalar operands are not allowed, use &#39;*&#39; instead</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>amax</strong> – Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.argmax" title="symjax.tensor.argmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmax()</span></code></a></dt><dd><p>Return the indices of the maximum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a>, <a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding max value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmax.</p>
<p>Don’t use <cite>amax</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">maximum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amax(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Maximum of the flattened array</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Maxima along the first axis</span>
<span class="go">array([2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Maxima along the second axis</span>
<span class="go">array([1, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
<p>You can use an initial value to compute the maximum of an empty slice, or
to initialize it to a different value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0, 10])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
maximum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.maximum">
<code class="sig-name descname">maximum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise maximum of array elements.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a>.
Original docstring below.</p>
<p>maximum(x1, x2, /, out=None, <a href="#id123"><span class="problematic" id="id124">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Compare two arrays and returns a new array containing the element-wise
maxima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The maximum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagates NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code></dt><dd><p>Element-wise maximum of two arrays, ignores NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignores NaNs.</p>
</dd>
</dl>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code>, <a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a>, <a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The maximum is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(x1</span> <span class="pre">&gt;=</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">x2)</span></code> when
neither x1 nor x2 are nans, but it is faster and does proper
broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([2, 5, 4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># broadcasting</span>
<span class="go">array([[ 1. ,  2. ],</span>
<span class="go">       [ 0.5,  2. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ NaN,  NaN,  NaN])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>.
Original docstring below.</p>
<p>Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
<cite>float64</cite> intermediate and return values are used for integer inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Type to use in computing the mean.  For integer inputs, the default
is <cite>float64</cite>; for floating point inputs, it is the same as the
input dtype.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, see dtype parameter above</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">average()</span></code></dt><dd><p>Weighted average</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.std" title="symjax.tensor.std"><code class="xref py py-func docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#symjax.tensor.var" title="symjax.tensor.var"><code class="xref py py-func docutils literal notranslate"><span class="pre">var()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanmean()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanstd()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanvar()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>The arithmetic mean is the sum of the elements along the axis divided
by the number of elements.</p>
<p>Note that for floating-point input, the mean is computed using the
same precision the input has.  Depending on the input data, this can
cause the results to be inaccurate, especially for <cite>float32</cite> (see
example below).  Specifying a higher-precision accumulator using the
<cite>dtype</cite> keyword can alleviate this issue.</p>
<p>By default, <cite>float16</cite> results are computed using <cite>float32</cite> intermediates
for extra precision.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.5,  3.5])</span>
</pre></div>
</div>
<p>In single precision, <cite>mean</cite> can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.54999924</span>
</pre></div>
</div>
<p>Computing the mean in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.55000000074505806</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.median">
<code class="sig-name descname">median</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite_input</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#median"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.median" title="symjax.tensor.median"><code class="xref py py-func docutils literal notranslate"><span class="pre">median()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.median" title="symjax.tensor.median"><code class="xref py py-func docutils literal notranslate"><span class="pre">median()</span></code></a>.
Original docstring below.</p>
<p>Returns the median of the array elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>median</strong> – A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>, <a class="reference internal" href="#symjax.tensor.percentile" title="symjax.tensor.percentile"><code class="xref py py-func docutils literal notranslate"><span class="pre">percentile()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the median of <code class="docutils literal notranslate"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> - i
e., <code class="docutils literal notranslate"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is odd, and the average of the
two middle values of <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> when <code class="docutils literal notranslate"><span class="pre">N</span></code> is even.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([ 6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([ 6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.meshgrid">
<code class="sig-name descname">meshgrid</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#meshgrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.meshgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return coordinate matrices from coordinate vectors.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.meshgrid" title="symjax.tensor.meshgrid"><code class="xref py py-func docutils literal notranslate"><span class="pre">meshgrid()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.meshgrid" title="symjax.tensor.meshgrid"><code class="xref py py-func docutils literal notranslate"><span class="pre">meshgrid()</span></code></a>.
Original docstring below.</p>
<p>Make N-D coordinate arrays for vectorized evaluations of
N-D scalar/vector fields over N-D grids, given
one-dimensional coordinate arrays x1, x2,…, xn.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.9: </span>1-D and 0-D cases are allowed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>X1, X2,…, XN</strong> – For vectors <cite>x1</cite>, <cite>x2</cite>,…, ‘xn’ with lengths <code class="docutils literal notranslate"><span class="pre">Ni=len(xi)</span></code> ,
return <code class="docutils literal notranslate"><span class="pre">(N1,</span> <span class="pre">N2,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’ij’
or <code class="docutils literal notranslate"><span class="pre">(N2,</span> <span class="pre">N1,</span> <span class="pre">N3,...Nn)</span></code> shaped arrays if indexing=’xy’
with the elements of <cite>xi</cite> repeated to fill the matrix along
the first dimension for <cite>x1</cite>, the second for <cite>x2</cite> and so on.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function supports both indexing conventions through the indexing
keyword argument.  Giving the string ‘ij’ returns a meshgrid with
matrix indexing, while ‘xy’ returns a meshgrid with Cartesian indexing.
In the 2-D case with inputs of length M and N, the outputs are of shape
(N, M) for ‘xy’ indexing and (M, N) for ‘ij’ indexing.  In the 3-D case
with inputs of length M, N and P, outputs are of shape (N, M, P) for
‘xy’ indexing and (M, N, P) for ‘ij’ indexing.  The difference is
illustrated by the following code snippet:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[i,j], yv[i,j]</span>

<span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="c1"># treat xv[j,i], yv[j,i]</span>
</pre></div>
</div>
<p>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">index_tricks.mgrid()</span></code></dt><dd><p>Construct a multi-dimensional “meshgrid” using indexing notation.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">index_tricks.ogrid()</span></code></dt><dd><p>Construct an open multi-dimensional “meshgrid” using indexing notation.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ],</span>
<span class="go">       [ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># make sparse output arrays</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xv</span>
<span class="go">array([[ 0. ,  0.5,  1. ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yv</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 1.]])</span>
</pre></div>
</div>
<p><cite>meshgrid</cite> is very useful to evaluate functions on a grid.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">xx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>amin</strong> – Minimum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.argmin" title="symjax.tensor.argmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">argmin()</span></code></a></dt><dd><p>Return the indices of the minimum values.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a>, <a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>NaN values are propagated, that is if at least one item is NaN, the
corresponding min value will be NaN as well. To ignore NaN values
(MATLAB behavior), please use nanmin.</p>
<p>Don’t use <cite>amin</cite> for element-wise comparison of 2 arrays; when
<code class="docutils literal notranslate"><span class="pre">a.shape[0]</span></code> is 2, <code class="docutils literal notranslate"><span class="pre">minimum(a[0],</span> <span class="pre">a[1])</span></code> is faster than
<code class="docutils literal notranslate"><span class="pre">amin(a,</span> <span class="pre">axis=0)</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>           <span class="c1"># Minimum of the flattened array</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>   <span class="c1"># Minima along the first axis</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># Minima along the second axis</span>
<span class="go">array([0, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">nan</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([[</span><span class="o">-</span><span class="mi">50</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([-50,   0])</span>
</pre></div>
</div>
<p>Notice that the initial value is used as one of the elements for which the
minimum is determined, unlike for the default argument Python’s max
function, which is only used for empty iterables.</p>
<p>Notice that this isn’t the same as Python’s <code class="docutils literal notranslate"><span class="pre">default</span></code> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="mi">6</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.minimum">
<code class="sig-name descname">minimum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise minimum of array elements.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a>.
Original docstring below.</p>
<p>minimum(x1, x2, /, out=None, <a href="#id125"><span class="problematic" id="id126">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Compare two arrays and returns a new array containing the element-wise
minima. If one of the elements being compared is a NaN, then that
element is returned. If both elements are NaNs then the first is
returned. The latter distinction is important for complex NaNs, which
are defined as at least one of the real or imaginary parts being a NaN.
The net effect is that NaNs are propagated.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The minimum of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagates NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code></dt><dd><p>Element-wise minimum of two arrays, ignores NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, propagates NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignores NaNs.</p>
</dd>
</dl>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code>, <a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a>, <a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The minimum is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(x1</span> <span class="pre">&lt;=</span> <span class="pre">x2,</span> <span class="pre">x1,</span> <span class="pre">x2)</span></code> when
neither x1 nor x2 are NaNs, but it is faster and does proper
broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([1, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="c1"># broadcasting</span>
<span class="go">array([[ 0.5,  0. ],</span>
<span class="go">       [ 0. ,  1. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ NaN,  NaN,  NaN])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">Inf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.mod">
<code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return element-wise remainder of division.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a>.
Original docstring below.</p>
<p>remainder(x1, x2, /, out=None, <a href="#id127"><span class="problematic" id="id128">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Computes the remainder complementary to the <cite>floor_divide</cite> function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor <cite>x2</cite>. The MATLAB function equivalent to <code class="docutils literal notranslate"><span class="pre">np.remainder</span></code>
is <code class="docutils literal notranslate"><span class="pre">mod</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This should not be confused with:</p>
<ul class="simple">
<li><p>Python 3.7’s <cite>math.remainder</cite> and C’s <code class="docutils literal notranslate"><span class="pre">remainder</span></code>, which
computes the IEEE remainder, which are the complement to
<code class="docutils literal notranslate"><span class="pre">round(x1</span> <span class="pre">/</span> <span class="pre">x2)</span></code>.</p></li>
<li><p>The MATLAB <code class="docutils literal notranslate"><span class="pre">rem</span></code> function and or the C <code class="docutils literal notranslate"><span class="pre">%</span></code> operator which is the
complement to <code class="docutils literal notranslate"><span class="pre">int(x1</span> <span class="pre">/</span> <span class="pre">x2)</span></code>.</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The element-wise remainder of the quotient <code class="docutils literal notranslate"><span class="pre">floor_divide(x1,</span> <span class="pre">x2)</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.floor_divide" title="symjax.tensor.floor_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor_divide()</span></code></a></dt><dd><p>Equivalent of Python <code class="docutils literal notranslate"><span class="pre">//</span></code> operator.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.divmod" title="symjax.tensor.divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></dt><dd><p>Simultaneous floor division and remainder.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.fmod" title="symjax.tensor.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">fmod()</span></code></a></dt><dd><p>Equivalent of the MATLAB <code class="docutils literal notranslate"><span class="pre">rem</span></code> function.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.divide" title="symjax.tensor.divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">divide()</span></code></a>, <a class="reference internal" href="#symjax.tensor.floor" title="symjax.tensor.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Returns 0 when <cite>x2</cite> is 0 and both <cite>x1</cite> and <cite>x2</cite> are (arrays of)
integers.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 3, 4, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.moveaxis">
<code class="sig-name descname">moveaxis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">destination</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#moveaxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.moveaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Move axes of an array to new positions.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.moveaxis" title="symjax.tensor.moveaxis"><code class="xref py py-func docutils literal notranslate"><span class="pre">moveaxis()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.moveaxis" title="symjax.tensor.moveaxis"><code class="xref py py-func docutils literal notranslate"><span class="pre">moveaxis()</span></code></a>.
Original docstring below.</p>
<p>Other axes remain in their original order.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.11.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>result</strong> – Array with moved axes. This array is a view of the input array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.transpose" title="symjax.tensor.transpose"><code class="xref py py-func docutils literal notranslate"><span class="pre">transpose()</span></code></a></dt><dd><p>Permute the dimensions of an array.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.swapaxes" title="symjax.tensor.swapaxes"><code class="xref py py-func docutils literal notranslate"><span class="pre">swapaxes()</span></code></a></dt><dd><p>Interchange two axes of an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 5, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 3, 4)</span>
</pre></div>
</div>
<p>These all achieve the same result:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(5, 4, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.multiply">
<code class="sig-name descname">multiply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply arguments element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.multiply" title="symjax.tensor.multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.multiply" title="symjax.tensor.multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code></a>.
Original docstring below.</p>
<p>multiply(x1, x2, /, out=None, <a href="#id129"><span class="problematic" id="id130">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The product of <cite>x1</cite> and <cite>x2</cite>, element-wise. Returns a scalar if
both <cite>x1</cite> and <cite>x2</cite> are scalars.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Equivalent to <cite>x1</cite> * <cite>x2</cite> in terms of array broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="go">8.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([[  0.,   1.,   4.],</span>
<span class="go">       [  0.,   4.,  10.],</span>
<span class="go">       [  0.,   7.,  16.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nan_to_num">
<code class="sig-name descname">nan_to_num</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#nan_to_num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.nan_to_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace NaN with zero and infinity with large finite numbers.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nan_to_num" title="symjax.tensor.nan_to_num"><code class="xref py py-func docutils literal notranslate"><span class="pre">nan_to_num()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nan_to_num" title="symjax.tensor.nan_to_num"><code class="xref py py-func docutils literal notranslate"><span class="pre">nan_to_num()</span></code></a>.
Original docstring below.</p>
<p>If <cite>x</cite> is inexact, NaN is replaced by zero, and infinity and -infinity
replaced by the respectively largest and most negative finite floating
point values representable by <code class="docutils literal notranslate"><span class="pre">x.dtype</span></code>.</p>
<p>For complex dtypes, the above is applied to each of the real and
imaginary components of <cite>x</cite> separately.</p>
<p>If <cite>x</cite> is not inexact, then no replacements are made.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – <cite>x</cite>, with the non-finite values replaced. If <cite>copy</cite> is False, this may
be <cite>x</cite> itself.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.isinf" title="symjax.tensor.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a></dt><dd><p>Shows which elements are positive or negative infinity.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">isneginf()</span></code></dt><dd><p>Shows which elements are negative infinity.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">isposinf()</span></code></dt><dd><p>Shows which elements are positive infinity.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a></dt><dd><p>Shows which elements are finite (not NaN, not infinity)</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="go">-1.7976931348623157e+308</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,</span>
<span class="go">        -1.28000000e+002,   1.28000000e+002])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="nb">complex</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([  1.79769313e+308 +0.00000000e+000j,</span>
<span class="go">         0.00000000e+000 +0.00000000e+000j,</span>
<span class="go">         0.00000000e+000 +1.79769313e+308j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nancumprod">
<code class="sig-name descname">nancumprod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.nancumprod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the cumulative product of array elements over a given axis treating Not a</dt><dd><p>Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nancumprod" title="symjax.tensor.nancumprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">nancumprod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nancumprod" title="symjax.tensor.nancumprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">nancumprod()</span></code></a>.
Original docstring below.</p>
<p>Ones are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Type of the returned array, as well as of the accumulator in which
the elements are multiplied.  If <em>dtype</em> is not specified, it
defaults to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with
a precision less than that of the default platform integer.  In
that case, the default platform integer is used instead.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nancumprod</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.cumprod()</span></code></dt><dd><p>Cumulative product across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1.,  2.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nancumsum">
<code class="sig-name descname">nancumsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.nancumsum" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the cumulative sum of array elements over a given axis treating Not a</dt><dd><p>Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nancumsum" title="symjax.tensor.nancumsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">nancumsum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nancumsum" title="symjax.tensor.nancumsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">nancumsum()</span></code></a>.
Original docstring below.</p>
<p>Zeros are returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Type of the returned array and of the accumulator in which the
elements are summed.  If <cite>dtype</cite> is not specified, it defaults
to the dtype of <cite>a</cite>, unless <cite>a</cite> has an integer dtype with a
precision less than that of the default platform integer.  In
that case, the default platform integer is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>nancumsum</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.cumsum()</span></code></dt><dd><p>Cumulative sum across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([ 1.,  3.,  6.,  6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 4.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nancumsum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 1.,  3.],</span>
<span class="go">       [ 3.,  3.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nanmax">
<code class="sig-name descname">nanmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.nanmax" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the maximum of an array or maximum along an axis, ignoring any</dt><dd><p>NaNs.  When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is
raised and NaN is returned for that slice.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>nanmax</strong> – An array with the same shape as <cite>a</cite>, with the specified axis removed.
If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray scalar is
returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code></dt><dd><p>Element-wise maximum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a></dt><dd><p>Element-wise maximum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a></dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code>, <a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.max.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 3.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 2.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nanmin">
<code class="sig-name descname">nanmin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.nanmin" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return minimum of an array or minimum along an axis, ignoring any NaNs.</dt><dd><p>When all-NaN slices are encountered a <code class="docutils literal notranslate"><span class="pre">RuntimeWarning</span></code> is raised and
Nan is returned for that slice.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nanmin" title="symjax.tensor.nanmin"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmin()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>nanmin</strong> – An array with the same shape as <cite>a</cite>, with the specified axis
removed.  If <cite>a</cite> is a 0-d array, or if axis is None, an ndarray
scalar is returned.  The same dtype as <cite>a</cite> is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.nanmax" title="symjax.tensor.nanmax"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanmax()</span></code></a></dt><dd><p>The maximum value of an array along a given axis, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.amin" title="symjax.tensor.amin"><code class="xref py py-func docutils literal notranslate"><span class="pre">amin()</span></code></a></dt><dd><p>The minimum value of an array along a given axis, propagating any NaNs.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">fmin()</span></code></dt><dd><p>Element-wise minimum of two arrays, ignoring any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.minimum" title="symjax.tensor.minimum"><code class="xref py py-func docutils literal notranslate"><span class="pre">minimum()</span></code></a></dt><dd><p>Element-wise minimum of two arrays, propagating any NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Shows which elements are Not a Number (NaN).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a></dt><dd><p>Shows which elements are neither NaN nor infinity.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.amax" title="symjax.tensor.amax"><code class="xref py py-func docutils literal notranslate"><span class="pre">amax()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">fmax()</span></code>, <a class="reference internal" href="#symjax.tensor.maximum" title="symjax.tensor.maximum"><code class="xref py py-func docutils literal notranslate"><span class="pre">maximum()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.min.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 1.,  3.])</span>
</pre></div>
</div>
<p>When positive infinity and negative infinity are present:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">-inf</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nanprod">
<code class="sig-name descname">nanprod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.nanprod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the product of array elements over a given axis treating Not a</dt><dd><p>Numbers (NaNs) as ones.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nanprod" title="symjax.tensor.nanprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanprod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nanprod" title="symjax.tensor.nanprod"><code class="xref py py-func docutils literal notranslate"><span class="pre">nanprod()</span></code></a>.
Original docstring below.</p>
<p>One is returned for slices that are all-NaN or empty.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>nanprod</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which case it is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.prod()</span></code></dt><dd><p>Product across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 3.,  2.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nansum">
<code class="sig-name descname">nansum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.nansum" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Return the sum of array elements over a given axis treating Not a</dt><dd><p>Numbers (NaNs) as zero.</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nansum" title="symjax.tensor.nansum"><code class="xref py py-func docutils literal notranslate"><span class="pre">nansum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nansum" title="symjax.tensor.nansum"><code class="xref py py-func docutils literal notranslate"><span class="pre">nansum()</span></code></a>.
Original docstring below.</p>
<p>In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>nansum</strong> – A new array holding the result is returned unless <cite>out</cite> is
specified, in which it is returned. The result has the same
size as <cite>a</cite>, and the same shape as <cite>a</cite> if <cite>axis</cite> is not None
or <cite>a</cite> is a 1-d array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.sum()</span></code></dt><dd><p>Sum across array propagating NaNs.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isnan" title="symjax.tensor.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a></dt><dd><p>Show which elements are NaN.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.isfinite" title="symjax.tensor.isfinite"><code class="xref py py-func docutils literal notranslate"><span class="pre">isfinite()</span></code></a></dt><dd><p>Show which elements are not NaN or +/-inf.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>If both positive and negative infinity are present, the sum will be Not
A Number (NaN).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 2.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span><span class="p">])</span>
<span class="go">-inf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="c1"># both +/- infinity present</span>
<span class="go">nan</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.nonzero">
<code class="sig-name descname">nonzero</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#nonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements that are non-zero.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nonzero" title="symjax.tensor.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.nonzero" title="symjax.tensor.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a>.
At present, JAX does not support JIT-compilation of <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.numpy.nonzero()</span></code>
because its output shape is data-dependent.</p>
<p>Original docstring below.</p>
<p>Returns a tuple of arrays, one for each dimension of <cite>a</cite>,
containing the indices of the non-zero elements in that
dimension. The values in <cite>a</cite> are always tested and returned in
row-major, C-style order. The corresponding non-zero
values can be obtained with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">[</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>
</pre></div>
</div>
<p>To group the indices by element, rather than dimension, use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">transpose</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</pre></div>
</div>
<p>The result of this is always a 2-D array, with a row for
each non-zero element.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tuple_of_arrays</strong> – Indices of elements that are non-zero.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">flatnonzero()</span></code></dt><dd><p>Return indices that are non-zero in the flattened version of the input array.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.nonzero()</span></code></dt><dd><p>Equivalent ndarray method.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.count_nonzero" title="symjax.tensor.count_nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">count_nonzero()</span></code></a></dt><dd><p>Counts the number of non-zero elements in the input array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 0, 0],</span>
<span class="go">       [0, 2, 0],</span>
<span class="go">       [1, 1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="go">array([1, 2, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">array([[0, 0],</span>
<span class="go">       [1, 1],</span>
<span class="go">       [2, 0],</span>
<span class="go">       [2, 1])</span>
</pre></div>
</div>
<p>A common use for <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> is to find the indices of an array, where
a condition is True.  Given an array <cite>a</cite>, the condition <cite>a</cite> &gt; 3 is a
boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)
yields the indices of the <cite>a</cite> where the condition is true.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span>
<span class="go">array([[False, False, False],</span>
<span class="go">       [ True,  True,  True],</span>
<span class="go">       [ True,  True,  True]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">nonzero</span></code> method of the boolean array can also be called.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
<span class="go">(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.not_equal">
<code class="sig-name descname">not_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 != x2) element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.not_equal" title="symjax.tensor.not_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">not_equal()</span></code></a>.
Original docstring below.</p>
<p>not_equal(x1, x2, /, out=None, <a href="#id131"><span class="problematic" id="id132">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Output array, element-wise comparison of <cite>x1</cite> and <cite>x2</cite>.
Typically of type bool, unless <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code> is passed.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.equal" title="symjax.tensor.equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.greater" title="symjax.tensor.greater"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater()</span></code></a>, <a class="reference internal" href="#symjax.tensor.greater_equal" title="symjax.tensor.greater_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">greater_equal()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less" title="symjax.tensor.less"><code class="xref py py-func docutils literal notranslate"><span class="pre">less()</span></code></a>, <a class="reference internal" href="#symjax.tensor.less_equal" title="symjax.tensor.less_equal"><code class="xref py py-func docutils literal notranslate"><span class="pre">less_equal()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])</span>
<span class="go">array([False,  True])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">array([[False,  True],</span>
<span class="go">       [False,  True]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.ones">
<code class="sig-name descname">ones</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with ones.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ones" title="symjax.tensor.ones"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ones" title="symjax.tensor.ones"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>int</em><em> or </em><em>sequence of ints</em>) – Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p></li>
<li><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array of ones with the given shape, dtype, and order.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.ones_like" title="symjax.tensor.ones_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones_like()</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.empty" title="symjax.tensor.empty"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty()</span></code></a></dt><dd><p>Return a new uninitialized array.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.full" title="symjax.tensor.full"><code class="xref py py-func docutils literal notranslate"><span class="pre">full()</span></code></a></dt><dd><p>Return a new array of given shape filled with value.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 1.,  1.,  1.,  1.,  1.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 1.],</span>
<span class="go">       [ 1.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 1.,  1.],</span>
<span class="go">       [ 1.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.ones_like">
<code class="sig-name descname">ones_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#ones_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type as a given array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ones_like" title="symjax.tensor.ones_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones_like()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ones_like" title="symjax.tensor.ones_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones_like()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Overrides the data type of the result.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array of ones with the same shape and type as <cite>a</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.empty_like" title="symjax.tensor.empty_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_like()</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.zeros_like" title="symjax.tensor.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a></dt><dd><p>Return an array of zeros with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.full_like" title="symjax.tensor.full_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">full_like()</span></code></a></dt><dd><p>Return a new array with shape of input filled with value.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ones" title="symjax.tensor.ones"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones()</span></code></a></dt><dd><p>Return a new array setting values to one.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 1.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.outer">
<code class="sig-name descname">outer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#outer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the outer product of two vectors.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.outer" title="symjax.tensor.outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">outer()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.outer" title="symjax.tensor.outer"><code class="xref py py-func docutils literal notranslate"><span class="pre">outer()</span></code></a>.
Original docstring below.</p>
<p>Given two vectors, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">[a0,</span> <span class="pre">a1,</span> <span class="pre">...,</span> <span class="pre">aM]</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">[b0,</span> <span class="pre">b1,</span> <span class="pre">...,</span> <span class="pre">bN]</span></code>,
the outer product <a href="#id175"><span class="problematic" id="id133">[1]_</span></a> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span><span class="o">*</span><span class="n">b0</span>  <span class="n">a0</span><span class="o">*</span><span class="n">b1</span> <span class="o">...</span> <span class="n">a0</span><span class="o">*</span><span class="n">bN</span> <span class="p">]</span>
 <span class="p">[</span><span class="n">a1</span><span class="o">*</span><span class="n">b0</span>    <span class="o">.</span>
 <span class="p">[</span> <span class="o">...</span>          <span class="o">.</span>
 <span class="p">[</span><span class="n">aM</span><span class="o">*</span><span class="n">b0</span>            <span class="n">aM</span><span class="o">*</span><span class="n">bN</span> <span class="p">]]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – <code class="docutils literal notranslate"><span class="pre">out[i,</span> <span class="pre">j]</span> <span class="pre">=</span> <span class="pre">a[i]</span> <span class="pre">*</span> <span class="pre">b[j]</span></code></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(M, N) ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.inner" title="symjax.tensor.inner"><code class="xref py py-func docutils literal notranslate"><span class="pre">inner()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.einsum" title="symjax.tensor.einsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">einsum()</span></code></a></dt><dd><p><code class="docutils literal notranslate"><span class="pre">einsum('i,j-&gt;ij',</span> <span class="pre">a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ufunc.outer()</span></code></dt><dd><p>A generalization to N dimensions and other operations. <code class="docutils literal notranslate"><span class="pre">np.multiply.outer(a.ravel(),</span> <span class="pre">b.ravel())</span></code> is the equivalent.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id134"><span class="brackets">1</span></dt>
<dd><p>: G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, 3rd
ed., Baltimore, MD, Johns Hopkins University Press, 1996,
pg. 8.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Make a (<em>very</em> coarse) grid for computing a Mandelbrot set:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rl</span>
<span class="go">array([[-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.],</span>
<span class="go">       [-2., -1.,  0.,  1.,  2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span>
<span class="go">array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],</span>
<span class="go">       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],</span>
<span class="go">       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],</span>
<span class="go">       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],</span>
<span class="go">       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">rl</span> <span class="o">+</span> <span class="n">im</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span>
<span class="go">array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],</span>
<span class="go">       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],</span>
<span class="go">       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="go">       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],</span>
<span class="go">       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</span>
</pre></div>
</div>
<p>An example using a “vector” of letters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([[a, aa, aaa],</span>
<span class="go">       [b, bb, bbb],</span>
<span class="go">       [c, cc, ccc]], dtype=object)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.pad">
<code class="sig-name descname">pad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">array</span></em>, <em class="sig-param"><span class="n">pad_width</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">'constant'</span></em>, <em class="sig-param"><span class="n">constant_values</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#pad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pads an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.pad" title="symjax.tensor.pad"><code class="xref py py-func docutils literal notranslate"><span class="pre">pad()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.pad" title="symjax.tensor.pad"><code class="xref py py-func docutils literal notranslate"><span class="pre">pad()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>pad</strong> – Padded array of rank equal to <cite>array</cite> with shape increased
according to <cite>pad_width</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>For an array with rank greater than 1, some of the padding of later
axes is calculated from padding of previous axes.  This is easiest to
think about with a rank 2 array where the corners of the padded array
are calculated by using padded values from the first axis.</p>
<p>The padding function, if used, should return a rank 1 array equal in
length to the vector argument with padded values replaced. It has the
following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">padding_func</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">iaxis_pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>where</p>
<blockquote>
<div><dl class="simple">
<dt>vector<span class="classifier">ndarray</span></dt><dd><p>A rank 1 array already padded with zeros.  Padded values are
vector[:pad_tuple[0]] and vector[-pad_tuple[1]:].</p>
</dd>
<dt>iaxis_pad_width<span class="classifier">tuple</span></dt><dd><p>A 2-tuple of ints, iaxis_pad_width[0] represents the number of
values padded at the beginning of vector where
iaxis_pad_width[1] represents the number of values padded at
the end of vector.</p>
</dd>
<dt>iaxis<span class="classifier">int</span></dt><dd><p>The axis currently being calculated.</p>
</dd>
<dt>kwargs<span class="classifier">dict</span></dt><dd><p>Any keyword arguments the function requires.</p>
</dd>
</dl>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;linear_ramp&#39;</span><span class="p">,</span> <span class="n">end_values</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="go">array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;maximum&#39;</span><span class="p">)</span>
<span class="go">array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="s1">&#39;median&#39;</span><span class="p">)</span>
<span class="go">array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="s1">&#39;minimum&#39;</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [3, 3, 3, 4, 3, 3, 3],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 2, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">)</span>
<span class="go">array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;reflect&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="n">reflect_type</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;wrap&#39;</span><span class="p">)</span>
<span class="go">array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pad_with</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">iaxis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">pad_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;padder&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[:</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="n">pad_width</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">pad_value</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">)</span>
<span class="go">array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10,  0,  1,  2, 10, 10],</span>
<span class="go">       [10, 10,  3,  4,  5, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10],</span>
<span class="go">       [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pad_with</span><span class="p">,</span> <span class="n">padder</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">array([[100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100,   0,   1,   2, 100, 100],</span>
<span class="go">       [100, 100,   3,   4,   5, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100, 100, 100]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.percentile">
<code class="sig-name descname">percentile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite_input</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#percentile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.percentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the qth percentile of the data along the specified axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.percentile" title="symjax.tensor.percentile"><code class="xref py py-func docutils literal notranslate"><span class="pre">percentile()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.percentile" title="symjax.tensor.percentile"><code class="xref py py-func docutils literal notranslate"><span class="pre">percentile()</span></code></a>.
Original docstring below.</p>
<p>Returns the qth percentile(s) of the array elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>percentile</strong> – If <cite>q</cite> is a single percentile and <cite>axis=None</cite>, then the result
is a scalar. If multiple percentiles are given, first axis of
the result corresponds to the percentiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scalar or ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.median" title="symjax.tensor.median"><code class="xref py py-func docutils literal notranslate"><span class="pre">median()</span></code></a></dt><dd><p>equivalent to <code class="docutils literal notranslate"><span class="pre">percentile(...,</span> <span class="pre">50)</span></code></p>
</dd>
</dl>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">nanpercentile()</span></code></p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.quantile" title="symjax.tensor.quantile"><code class="xref py py-func docutils literal notranslate"><span class="pre">quantile()</span></code></a></dt><dd><p>equivalent to percentile, except with q in the range [0, 1].</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the <code class="docutils literal notranslate"><span class="pre">q</span></code>-th percentile of
<code class="docutils literal notranslate"><span class="pre">V</span></code> is the value <code class="docutils literal notranslate"><span class="pre">q/100</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the percentile if the normalized ranking does not
match the location of <code class="docutils literal notranslate"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal notranslate"><span class="pre">q=50</span></code>, the same as the minimum if <code class="docutils literal notranslate"><span class="pre">q=0</span></code> and the
same as the maximum if <code class="docutils literal notranslate"><span class="pre">q=100</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 7.],</span>
<span class="go">       [ 2.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The different types of interpolation can be visualized graphically:</p>
<p>(<a class="reference external" href="../modules/tensor-1.py">Source code</a>, <a class="reference external" href="../modules/tensor-1.png">png</a>, <a class="reference external" href="../modules/tensor-1.hires.png">hires.png</a>, <a class="reference external" href="../modules/tensor-1.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="../_images/tensor-1.png" src="../_images/tensor-1.png" />
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.polyval">
<code class="sig-name descname">polyval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#polyval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.polyval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a polynomial at specific values.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.polyval" title="symjax.tensor.polyval"><code class="xref py py-func docutils literal notranslate"><span class="pre">polyval()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.polyval" title="symjax.tensor.polyval"><code class="xref py py-func docutils literal notranslate"><span class="pre">polyval()</span></code></a>.
Original docstring below.</p>
<p>If <cite>p</cite> is of length N, this function returns the value:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">p[0]*x**(N-1)</span> <span class="pre">+</span> <span class="pre">p[1]*x**(N-2)</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">p[N-2]*x</span> <span class="pre">+</span> <span class="pre">p[N-1]</span></code></p>
</div></blockquote>
<p>If <cite>x</cite> is a sequence, then <cite>p(x)</cite> is returned for each element of <cite>x</cite>.
If <cite>x</cite> is another polynomial then the composite polynomial <cite>p(x(t))</cite>
is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>values</strong> – If <cite>x</cite> is a poly1d instance, the result is the composition of the two
polynomials, i.e., <cite>x</cite> is “substituted” in <cite>p</cite> and the simplified
result is returned. In addition, the type of <cite>x</cite> - array_like or
poly1d - governs the type of the output: <cite>x</cite> array_like =&gt; <cite>values</cite>
array_like, <cite>x</cite> a poly1d object =&gt; <cite>values</cite> is also.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or poly1d</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">poly1d()</span></code></dt><dd><p>A polynomial class.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Horner’s scheme <a href="#id176"><span class="problematic" id="id135">[1]_</span></a> is used to evaluate the polynomial. Even so,
for polynomials of high degree the values may be inaccurate due to
rounding errors. Use carefully.</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id136"><span class="brackets">1</span></dt>
<dd><p>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
trans. Ed.), <em>Handbook of Mathematics</em>, New York, Van Nostrand
Reinhold Co., 1985, pg. 720.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1"># 3 * 5**2 + 0 * 5**1 + 1</span>
<span class="go">76</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">poly1d([ 76.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">76</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">poly1d([ 76.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.power">
<code class="sig-name descname">power</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.power" title="Permalink to this definition">¶</a></dt>
<dd><p>First array elements raised to powers from second array, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.power" title="symjax.tensor.power"><code class="xref py py-func docutils literal notranslate"><span class="pre">power()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.power" title="symjax.tensor.power"><code class="xref py py-func docutils literal notranslate"><span class="pre">power()</span></code></a>.
Original docstring below.</p>
<p>power(x1, x2, /, out=None, <a href="#id137"><span class="problematic" id="id138">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Raise each base in <cite>x1</cite> to the positionally-corresponding power in
<cite>x2</cite>.  <cite>x1</cite> and <cite>x2</cite> must be broadcastable to the same shape. Note that an
integer type raised to a negative integer power will raise a ValueError.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The bases in <cite>x1</cite> raised to the exponents in <cite>x2</cite>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.float_power" title="symjax.tensor.float_power"><code class="xref py py-func docutils literal notranslate"><span class="pre">float_power()</span></code></a></dt><dd><p>power function that promotes integers to float</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Cube each element in a list.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([  0,   1,   8,  27,  64, 125])</span>
</pre></div>
</div>
<p>Raise the bases to different exponents.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([  0.,   1.,   8.,  27.,  16.,   5.])</span>
</pre></div>
</div>
<p>The effect of broadcasting.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span>
<span class="go">array([[1, 2, 3, 3, 2, 1],</span>
<span class="go">       [1, 2, 3, 3, 2, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([[ 0,  1,  8, 27, 16,  5],</span>
<span class="go">       [ 0,  1,  8, 27, 16,  5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.positive">
<code class="sig-name descname">positive</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerical positive, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.positive" title="symjax.tensor.positive"><code class="xref py py-func docutils literal notranslate"><span class="pre">positive()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.positive" title="symjax.tensor.positive"><code class="xref py py-func docutils literal notranslate"><span class="pre">positive()</span></code></a>.
Original docstring below.</p>
<p>positive(x, /, out=None, <a href="#id139"><span class="problematic" id="id140">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.13.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – Returned array or scalar: <cite>y = +x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Equivalent to <cite>x.copy()</cite>, but only defined for types that support
arithmetic.</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.prod" title="symjax.tensor.prod"><code class="xref py py-func docutils literal notranslate"><span class="pre">prod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.prod" title="symjax.tensor.prod"><code class="xref py py-func docutils literal notranslate"><span class="pre">prod()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <cite>a</cite> is used by
default unless <cite>a</cite> has an integer dtype of less precision than the
default platform integer.  In that case, if <cite>a</cite> is signed then the
platform integer is used while if <cite>a</cite> is unsigned then an unsigned
integer of the same precision as the platform integer is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>product_along_axis</strong> – An array shaped as <cite>a</cite> but with the specified axis removed.
Returns a reference to <cite>out</cite> if specified.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, see <cite>dtype</cite> parameter above.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.prod()</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">16</span>
</pre></div>
</div>
<p>The product of an empty array is the neutral element 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>By default, calculate the product of all elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Even when the input array is two-dimensional:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="go">24.0</span>
</pre></div>
</div>
<p>But we can also specify the axis over which to multiply:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([  2.,  12.])</span>
</pre></div>
</div>
<p>If the type of <cite>x</cite> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>x</cite> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also start the product with a value other than one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.product">
<code class="sig-name descname">product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the product of array elements over a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.prod" title="symjax.tensor.prod"><code class="xref py py-func docutils literal notranslate"><span class="pre">prod()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.prod" title="symjax.tensor.prod"><code class="xref py py-func docutils literal notranslate"><span class="pre">prod()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – The type of the returned array, as well as of the accumulator in
which the elements are multiplied.  The dtype of <cite>a</cite> is used by
default unless <cite>a</cite> has an integer dtype of less precision than the
default platform integer.  In that case, if <cite>a</cite> is signed then the
platform integer is used while if <cite>a</cite> is unsigned then an unsigned
integer of the same precision as the platform integer is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>product_along_axis</strong> – An array shaped as <cite>a</cite> but with the specified axis removed.
Returns a reference to <cite>out</cite> if specified.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, see <cite>dtype</cite> parameter above.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.prod()</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.  That means that, on a 32-bit platform:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">,</span> <span class="mi">536870910</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># random</span>
<span class="go">16</span>
</pre></div>
</div>
<p>The product of an empty array is the neutral element 1:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([])</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>By default, calculate the product of all elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">])</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Even when the input array is two-dimensional:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="go">24.0</span>
</pre></div>
</div>
<p>But we can also specify the axis over which to multiply:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([  2.,  12.])</span>
</pre></div>
</div>
<p>If the type of <cite>x</cite> is unsigned, then the output type is
the unsigned platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If <cite>x</cite> is of a signed integer type, then the output type
is the default platform integer:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
<span class="go">True</span>
</pre></div>
</div>
<p>You can also start the product with a value other than one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.promote_types">
<code class="sig-name descname">promote_types</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/dtypes.html#promote_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.promote_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type to which a binary operation should cast its arguments.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.promote_types" title="symjax.tensor.promote_types"><code class="xref py py-func docutils literal notranslate"><span class="pre">promote_types()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<blockquote>
<div><p>Returns:
A <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code> object.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite_input</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#quantile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.quantile" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Compute the <a href="#id141"><span class="problematic" id="id142">`</span></a>q`th quantile of the data along the specified axis.</dt><dd><p>..versionadded:: 1.15.0</p>
</dd>
</dl>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.quantile" title="symjax.tensor.quantile"><code class="xref py py-func docutils literal notranslate"><span class="pre">quantile()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.quantile" title="symjax.tensor.quantile"><code class="xref py py-func docutils literal notranslate"><span class="pre">quantile()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>quantile</strong> – If <cite>q</cite> is a single quantile and <cite>axis=None</cite>, then the result
is a scalar. If multiple quantiles are given, first axis of
the result corresponds to the quantiles. The other axes are
the axes that remain after the reduction of <cite>a</cite>. If the input
contains integers or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, the output
data-type is <code class="docutils literal notranslate"><span class="pre">float64</span></code>. Otherwise, the output data-type is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>scalar or ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a></p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.percentile" title="symjax.tensor.percentile"><code class="xref py py-func docutils literal notranslate"><span class="pre">percentile()</span></code></a></dt><dd><p>equivalent to quantile, but with q in the range [0, 100].</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.median" title="symjax.tensor.median"><code class="xref py py-func docutils literal notranslate"><span class="pre">median()</span></code></a></dt><dd><p>equivalent to <code class="docutils literal notranslate"><span class="pre">quantile(...,</span> <span class="pre">0.5)</span></code></p>
</dd>
</dl>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">nanquantile()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the <code class="docutils literal notranslate"><span class="pre">q</span></code>-th quantile of
<code class="docutils literal notranslate"><span class="pre">V</span></code> is the value <code class="docutils literal notranslate"><span class="pre">q</span></code> of the way from the minimum to the
maximum in a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>. The values and distances of
the two nearest neighbors as well as the <cite>interpolation</cite> parameter
will determine the quantile if the normalized ranking does not
match the location of <code class="docutils literal notranslate"><span class="pre">q</span></code> exactly. This function is the same as
the median if <code class="docutils literal notranslate"><span class="pre">q=0.5</span></code>, the same as the minimum if <code class="docutils literal notranslate"><span class="pre">q=0.0</span></code> and the
same as the maximum if <code class="docutils literal notranslate"><span class="pre">q=1.0</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[10,  7,  4],</span>
<span class="go">       [ 3,  2,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[ 7.],</span>
<span class="go">       [ 2.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[ 6.5,  4.5,  2.5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([ 7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.rad2deg">
<code class="sig-name descname">rad2deg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#rad2deg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.rad2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from radians to degrees.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.rad2deg" title="symjax.tensor.rad2deg"><code class="xref py py-func docutils literal notranslate"><span class="pre">rad2deg()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.rad2deg" title="symjax.tensor.rad2deg"><code class="xref py py-func docutils literal notranslate"><span class="pre">rad2deg()</span></code></a>.
Original docstring below.</p>
<p>rad2deg(x, /, out=None, <a href="#id143"><span class="problematic" id="id144">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding angle in degrees.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.deg2rad" title="symjax.tensor.deg2rad"><code class="xref py py-func docutils literal notranslate"><span class="pre">deg2rad()</span></code></a></dt><dd><p>Convert angles from degrees to radians.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap()</span></code></dt><dd><p>Remove large jumps in angle by wrapping.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p>rad2deg(x) is <code class="docutils literal notranslate"><span class="pre">180</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">/</span> <span class="pre">pi</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">90.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.radians">
<code class="sig-name descname">radians</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from degrees to radians.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.deg2rad" title="symjax.tensor.deg2rad"><code class="xref py py-func docutils literal notranslate"><span class="pre">deg2rad()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.deg2rad" title="symjax.tensor.deg2rad"><code class="xref py py-func docutils literal notranslate"><span class="pre">deg2rad()</span></code></a>.
Original docstring below.</p>
<p>deg2rad(x, /, out=None, <a href="#id145"><span class="problematic" id="id146">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding angle in radians.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.rad2deg" title="symjax.tensor.rad2deg"><code class="xref py py-func docutils literal notranslate"><span class="pre">rad2deg()</span></code></a></dt><dd><p>Convert angles from radians to degrees.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap()</span></code></dt><dd><p>Remove large jumps in angle by wrapping.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">deg2rad(x)</span></code> is <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">pi</span> <span class="pre">/</span> <span class="pre">180</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">180</span><span class="p">)</span>
<span class="go">3.1415926535897931</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.ravel">
<code class="sig-name descname">ravel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#ravel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous flattened array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ravel" title="symjax.tensor.ravel"><code class="xref py py-func docutils literal notranslate"><span class="pre">ravel()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.ravel" title="symjax.tensor.ravel"><code class="xref py py-func docutils literal notranslate"><span class="pre">ravel()</span></code></a>.
Original docstring below.</p>
<p>A 1-D array, containing the elements of the input, is returned.  A copy is
made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input
array. (for example, a masked array will be returned for a masked array
input)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – y is an array of the same subtype as <cite>a</cite>, with shape <code class="docutils literal notranslate"><span class="pre">(a.size,)</span></code>.
Note that matrices are special cased for backward compatibility, if <cite>a</cite>
is a matrix, then y is a 1-D ndarray.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.flat()</span></code></dt><dd><p>1-D iterator over an array.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.flatten()</span></code></dt><dd><p>1-D array copy of the elements of an array in row-major order.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.reshape()</span></code></dt><dd><p>Change the shape of an array without changing its data.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>In row-major, C-style order, in two dimensions, the row index
varies the slowest, and the column index the quickest.  This can
be generalized to multiple dimensions, where row-major order
implies that the index along the first axis varies slowest, and
the index along the last quickest.  The opposite holds for
column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code class="docutils literal notranslate"><span class="pre">arr.reshape(-1)</span></code>
may be preferable.</p>
<p class="rubric">Examples</p>
<p>It is equivalent to <code class="docutils literal notranslate"><span class="pre">reshape(-1,</span> <span class="pre">order=order)</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">))</span>
<span class="go">[1 4 2 5 3 6]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘A’, it will preserve the array’s ‘C’ or ‘F’ ordering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="go">[1 4 2 5 3 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">))</span>
<span class="go">[1 2 3 4 5 6]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘K’, it will preserve orderings that are neither ‘C’
nor ‘F’, but won’t reverse axes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">a</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([2, 1, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span>
<span class="go">array([[[ 0,  2,  4],</span>
<span class="go">        [ 1,  3,  5]],</span>
<span class="go">       [[ 6,  8, 10],</span>
<span class="go">        [ 7,  9, 11]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="go">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.real">
<code class="sig-name descname">real</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#real"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part of the complex argument.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.real" title="symjax.tensor.real"><code class="xref py py-func docutils literal notranslate"><span class="pre">real()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.real" title="symjax.tensor.real"><code class="xref py py-func docutils literal notranslate"><span class="pre">real()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The real component of the complex argument. If <cite>val</cite> is real, the type
of <cite>val</cite> is used for the output.  If <cite>val</cite> has complex elements, the
returned type is float.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">real_if_close()</span></code>, <a class="reference internal" href="#symjax.tensor.imag" title="symjax.tensor.imag"><code class="xref py py-func docutils literal notranslate"><span class="pre">imag()</span></code></a>, <a class="reference internal" href="#symjax.tensor.angle" title="symjax.tensor.angle"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span>
<span class="go">array([ 1.,  3.,  5.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 9.+2.j,  9.+4.j,  9.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 9.+2.j,  8.+4.j,  7.+6.j])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.remainder">
<code class="sig-name descname">remainder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#remainder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.remainder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return element-wise remainder of division.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.remainder" title="symjax.tensor.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">remainder()</span></code></a>.
Original docstring below.</p>
<p>remainder(x1, x2, /, out=None, <a href="#id147"><span class="problematic" id="id148">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Computes the remainder complementary to the <cite>floor_divide</cite> function.  It is
equivalent to the Python modulus operator``x1 % x2`` and has the same sign
as the divisor <cite>x2</cite>. The MATLAB function equivalent to <code class="docutils literal notranslate"><span class="pre">np.remainder</span></code>
is <code class="docutils literal notranslate"><span class="pre">mod</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This should not be confused with:</p>
<ul class="simple">
<li><p>Python 3.7’s <cite>math.remainder</cite> and C’s <code class="docutils literal notranslate"><span class="pre">remainder</span></code>, which
computes the IEEE remainder, which are the complement to
<code class="docutils literal notranslate"><span class="pre">round(x1</span> <span class="pre">/</span> <span class="pre">x2)</span></code>.</p></li>
<li><p>The MATLAB <code class="docutils literal notranslate"><span class="pre">rem</span></code> function and or the C <code class="docutils literal notranslate"><span class="pre">%</span></code> operator which is the
complement to <code class="docutils literal notranslate"><span class="pre">int(x1</span> <span class="pre">/</span> <span class="pre">x2)</span></code>.</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The element-wise remainder of the quotient <code class="docutils literal notranslate"><span class="pre">floor_divide(x1,</span> <span class="pre">x2)</span></code>.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.floor_divide" title="symjax.tensor.floor_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor_divide()</span></code></a></dt><dd><p>Equivalent of Python <code class="docutils literal notranslate"><span class="pre">//</span></code> operator.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.divmod" title="symjax.tensor.divmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">divmod()</span></code></a></dt><dd><p>Simultaneous floor division and remainder.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.fmod" title="symjax.tensor.fmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">fmod()</span></code></a></dt><dd><p>Equivalent of the MATLAB <code class="docutils literal notranslate"><span class="pre">rem</span></code> function.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.divide" title="symjax.tensor.divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">divide()</span></code></a>, <a class="reference internal" href="#symjax.tensor.floor" title="symjax.tensor.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Returns 0 when <cite>x2</cite> is 0 and both <cite>x1</cite> and <cite>x2</cite> are (arrays of)
integers.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">array([0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 3, 4, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.repeat">
<code class="sig-name descname">repeat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">repeats</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.repeat" title="symjax.tensor.repeat"><code class="xref py py-func docutils literal notranslate"><span class="pre">repeat()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.repeat" title="symjax.tensor.repeat"><code class="xref py py-func docutils literal notranslate"><span class="pre">repeat()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>repeated_array</strong> – Output array which has the same shape as <cite>a</cite>, except along
the given axis.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.tile" title="symjax.tensor.tile"><code class="xref py py-func docutils literal notranslate"><span class="pre">tile()</span></code></a></dt><dd><p>Tile an array.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([3, 3, 3, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 2, 2, 2],</span>
<span class="go">       [3, 3, 3, 4, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.reshape">
<code class="sig-name descname">reshape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">newshape</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#reshape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a new shape to an array without changing its data.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.reshape" title="symjax.tensor.reshape"><code class="xref py py-func docutils literal notranslate"><span class="pre">reshape()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.reshape" title="symjax.tensor.reshape"><code class="xref py py-func docutils literal notranslate"><span class="pre">reshape()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>reshaped_array</strong> – This will be a new view object if possible; otherwise, it will
be a copy.  Note there is no guarantee of the <em>memory layout</em> (C- or
Fortran- contiguous) of the returned array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.reshape()</span></code></dt><dd><p>Equivalent method.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>It is not always possible to change the shape of an array without
copying the data. If you want an error to be raised when the data is copied,
you should assign the new shape to the shape attribute of the array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go"># A transpose makes the array non-contiguous</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
<span class="go"># Taking a view makes it possible to modify the shape without modifying</span>
<span class="go"># the initial object.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">AttributeError: incompatible shape for a non-contiguous array</span>
</pre></div>
</div>
<p>The <cite>order</cite> keyword gives the index ordering both for <em>fetching</em> the values
from <cite>a</cite>, and then <em>placing</em> the values into the output array.
For example, let’s say you have an array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [4, 5]])</span>
</pre></div>
</div>
<p>You can think of reshaping as first raveling the array (using the given
index order), then inserting the elements from the raveled array into the
new array using the same kind of index ordering as was used for the
raveling.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># C-like index ordering</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="c1"># equivalent to C ravel then C reshape</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span> <span class="c1"># Fortran-like index ordering</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([[0, 4, 3],</span>
<span class="go">       [2, 1, 5]])</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">array([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
<span class="go">array([1, 4, 2, 5, 3, 6])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>       <span class="c1"># the unspecified value is inferred to be 2</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.roll">
<code class="sig-name descname">roll</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">shift</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#roll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.roll" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll array elements along a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.roll" title="symjax.tensor.roll"><code class="xref py py-func docutils literal notranslate"><span class="pre">roll()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.roll" title="symjax.tensor.roll"><code class="xref py py-func docutils literal notranslate"><span class="pre">roll()</span></code></a>.
Original docstring below.</p>
<p>Elements that roll beyond the last position are re-introduced at
the first.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>res</strong> – Output array, with the same shape as <cite>a</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">rollaxis()</span></code></dt><dd><p>Roll the specified axis backwards, until it lies in a given position.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>Supports rolling over multiple dimensions simultaneously.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span>
<span class="go">array([[0, 1, 2, 3, 4],</span>
<span class="go">       [5, 6, 7, 8, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">array([[9, 0, 1, 2, 3],</span>
<span class="go">       [4, 5, 6, 7, 8]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([[5, 6, 7, 8, 9],</span>
<span class="go">       [0, 1, 2, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[4, 0, 1, 2, 3],</span>
<span class="go">       [9, 5, 6, 7, 8]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.rot90">
<code class="sig-name descname">rot90</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">0, 1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#rot90"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.rot90" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate an array by 90 degrees in the plane specified by axes.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.rot90" title="symjax.tensor.rot90"><code class="xref py py-func docutils literal notranslate"><span class="pre">rot90()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.rot90" title="symjax.tensor.rot90"><code class="xref py py-func docutils literal notranslate"><span class="pre">rot90()</span></code></a>.
Original docstring below.</p>
<p>Rotation direction is from the first towards the second axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – A rotated view of <cite>m</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.flip" title="symjax.tensor.flip"><code class="xref py py-func docutils literal notranslate"><span class="pre">flip()</span></code></a></dt><dd><p>Reverse the order of elements in an array along the given axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.fliplr" title="symjax.tensor.fliplr"><code class="xref py py-func docutils literal notranslate"><span class="pre">fliplr()</span></code></a></dt><dd><p>Flip an array horizontally.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.flipud" title="symjax.tensor.flipud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flipud()</span></code></a></dt><dd><p>Flip an array vertically.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([[2, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [2, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[1, 3],</span>
<span class="go">        [0, 2]],</span>
<span class="go">       [[5, 7],</span>
<span class="go">        [4, 6]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">decimals</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#round"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round an array to the given number of decimals.</p>
<p>LAX-backend implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">round_()</span></code>.
ADDITIONOriginal docstring below.</p>
<p>LA</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.row_stack">
<code class="sig-name descname">row_stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tup</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.row_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a>.
Original docstring below.</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>stacked</strong> – The array formed by stacking the given arrays, will be at least 2-D.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a></dt><dd><p>Stack arrays in sequence horizontally (column wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third dimension).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vsplit" title="symjax.tensor.vsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">vsplit()</span></code></a></dt><dd><p>Split array into a list of multiple sub-arrays vertically.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.block" title="symjax.tensor.block"><code class="xref py py-func docutils literal notranslate"><span class="pre">block()</span></code></a></dt><dd><p>Assemble arrays from blocks.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sign">
<code class="sig-name descname">sign</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#sign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an element-wise indication of the sign of a number.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sign" title="symjax.tensor.sign"><code class="xref py py-func docutils literal notranslate"><span class="pre">sign()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sign" title="symjax.tensor.sign"><code class="xref py py-func docutils literal notranslate"><span class="pre">sign()</span></code></a>.
Original docstring below.</p>
<p>sign(x, /, out=None, <a href="#id149"><span class="problematic" id="id150">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>The <cite>sign</cite> function returns <code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0,</span> <span class="pre">0</span> <span class="pre">if</span> <span class="pre">x==0,</span> <span class="pre">1</span> <span class="pre">if</span> <span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  nan
is returned for nan inputs.</p>
<p>For complex inputs, the <cite>sign</cite> function returns
<code class="docutils literal notranslate"><span class="pre">sign(x.real)</span> <span class="pre">+</span> <span class="pre">0j</span> <span class="pre">if</span> <span class="pre">x.real</span> <span class="pre">!=</span> <span class="pre">0</span> <span class="pre">else</span> <span class="pre">sign(x.imag)</span> <span class="pre">+</span> <span class="pre">0j</span></code>.</p>
<p>complex(nan, 0) is returned for complex nan inputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The sign of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>There is more than one definition of sign in common use for complex
numbers.  The definition used here is equivalent to <span class="math notranslate nohighlight">\(x/\sqrt{x*x}\)</span>
which is different from a common alternative, <span class="math notranslate nohighlight">\(x/|x|\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">([</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">])</span>
<span class="go">array([-1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="mi">5</span><span class="o">-</span><span class="mi">2</span><span class="n">j</span><span class="p">)</span>
<span class="go">(1+0j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.signbit">
<code class="sig-name descname">signbit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#signbit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.signbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns element-wise True where signbit is set (less than zero).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.signbit" title="symjax.tensor.signbit"><code class="xref py py-func docutils literal notranslate"><span class="pre">signbit()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.signbit" title="symjax.tensor.signbit"><code class="xref py py-func docutils literal notranslate"><span class="pre">signbit()</span></code></a>.
Original docstring below.</p>
<p>signbit(x, /, out=None, <a href="#id151"><span class="problematic" id="id152">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>result</strong> – Output array, or reference to <cite>out</cite> if that was supplied.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray of bool</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">signbit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">]))</span>
<span class="go">array([False,  True, False])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sin">
<code class="sig-name descname">sin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric sine, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sin" title="symjax.tensor.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">sin()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sin" title="symjax.tensor.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">sin()</span></code></a>.
Original docstring below.</p>
<p>sin(x, /, out=None, <a href="#id153"><span class="problematic" id="id154">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The sine of each element of x.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.arcsin" title="symjax.tensor.arcsin"><code class="xref py py-func docutils literal notranslate"><span class="pre">arcsin()</span></code></a>, <a class="reference internal" href="#symjax.tensor.sinh" title="symjax.tensor.sinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinh()</span></code></a>, <a class="reference internal" href="#symjax.tensor.cos" title="symjax.tensor.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">cos()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The sine is one of the fundamental functions of trigonometry (the
mathematical study of triangles).  Consider a circle of radius 1
centered on the origin.  A ray comes in from the <span class="math notranslate nohighlight">\(+x\)</span> axis, makes
an angle at the origin (measured counter-clockwise from that axis), and
departs from the origin.  The <span class="math notranslate nohighlight">\(y\)</span> coordinate of the outgoing
ray’s intersection with the unit circle is the sine of that angle.  It
ranges from -1 for <span class="math notranslate nohighlight">\(x=3\pi / 2\)</span> to +1 for <span class="math notranslate nohighlight">\(\pi / 2.\)</span>  The
function has zeroes where the angle is a multiple of <span class="math notranslate nohighlight">\(\pi\)</span>.
Sines of angles between <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(2\pi\)</span> are negative.
The numerous properties of the sine and related functions are included
in any standard trigonometry text.</p>
<p class="rubric">Examples</p>
<p>Print sine of one angle:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Print sines of an array of angles given in degrees:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">45.</span><span class="p">,</span> <span class="mf">60.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.</span> <span class="p">)</span>
<span class="go">array([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])</span>
</pre></div>
</div>
<p>Plot the sine function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pylab</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">201</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Angle [rad]&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;sin(x)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sinc">
<code class="sig-name descname">sinc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#sinc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.sinc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sinc function.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sinc" title="symjax.tensor.sinc"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinc()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sinc" title="symjax.tensor.sinc"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinc()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>The sinc function is <span class="math notranslate nohighlight">\(\sin(\pi x)/(\pi x)\)</span>.</p>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">sinc(x)</span></code>, which has the same shape as the input.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">sinc(0)</span></code> is the limit value 1.</p>
<p>The name sinc is short for “sine cardinal” or “sinus cardinalis”.</p>
<p>The sinc function is used in various signal processing applications,
including in anti-aliasing, in the construction of a Lanczos resampling
filter, and in interpolation.</p>
<p>For bandlimited interpolation of discrete-time signals, the ideal
interpolation kernel is proportional to the sinc function.</p>
<dl class="footnote brackets">
<dt class="label" id="id155"><span class="brackets">1</span></dt>
<dd><p>Weisstein, Eric W. “Sinc Function.” From MathWorld–A Wolfram Web
Resource. <a class="reference external" href="http://mathworld.wolfram.com/SincFunction.html">http://mathworld.wolfram.com/SincFunction.html</a></p>
</dd>
<dt class="label" id="id156"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Sinc function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Sinc_function">http://en.wikipedia.org/wiki/Sinc_function</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">41</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([ -3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02,</span>
<span class="go">        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span>
<span class="go">         6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span>
<span class="go">         8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span>
<span class="go">        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span>
<span class="go">         3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span>
<span class="go">         7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span>
<span class="go">         9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span>
<span class="go">         2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span>
<span class="go">        -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span>
<span class="go">        -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span>
<span class="go">         1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span>
<span class="go">        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span>
<span class="go">        -4.92362781e-02,  -3.89804309e-17])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Sinc Function&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Amplitude&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
<span class="go">&lt;matplotlib.text.Text object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>It works in 2-D as well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">401</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
<span class="go">&lt;matplotlib.image.AxesImage object at 0x...&gt;</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sinh">
<code class="sig-name descname">sinh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic sine, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sinh" title="symjax.tensor.sinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinh()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sinh" title="symjax.tensor.sinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">sinh()</span></code></a>.
Original docstring below.</p>
<p>sinh(x, /, out=None, <a href="#id157"><span class="problematic" id="id158">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">1/2</span> <span class="pre">*</span> <span class="pre">(np.exp(x)</span> <span class="pre">-</span> <span class="pre">np.exp(-x))</span></code> or
<code class="docutils literal notranslate"><span class="pre">-1j</span> <span class="pre">*</span> <span class="pre">np.sin(1j*x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding hyperbolic sine values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="c1"># (exact value is 0)</span>
<span class="go">1.2246063538223773e-016j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Discrepancy due to vagaries of floating point arithmetic.</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sinh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">invalid return array shape</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sort">
<code class="sig-name descname">sort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'quicksort'</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sorted copy of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sort" title="symjax.tensor.sort"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sort" title="symjax.tensor.sort"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sorted_array</strong> – Array of the same type and shape as <cite>a</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.sort()</span></code></dt><dd><p>Method to sort an array in-place.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.argsort" title="symjax.tensor.argsort"><code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code></a></dt><dd><p>Indirect sort.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">lexsort()</span></code></dt><dd><p>Indirect stable sort on multiple keys.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">searchsorted()</span></code></dt><dd><p>Find elements in a sorted array.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">partition()</span></code></dt><dd><p>Partial sort.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The three available algorithms have the following
properties:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 14%" />
<col style="width: 25%" />
<col style="width: 24%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>kind</p></th>
<th class="head"><p>speed</p></th>
<th class="head"><p>worst case</p></th>
<th class="head"><p>work space</p></th>
<th class="head"><p>stable</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘quicksort’</p></td>
<td><p>1</p></td>
<td><p>O(n^2)</p></td>
<td><p>0</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p>‘mergesort’</p></td>
<td><p>2</p></td>
<td><p>O(n*log(n))</p></td>
<td><p>~n/2</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p>‘heapsort’</p></td>
<td><p>3</p></td>
<td><p>O(n*log(n))</p></td>
<td><p>0</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
<p>All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.</p>
<p>Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:</p>
<blockquote>
<div><ul class="simple">
<li><p>Real: [R, nan]</p></li>
<li><p>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</p></li>
</ul>
</div></blockquote>
<p>where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
<p>quicksort has been changed to an introsort which will switch
heapsort when it does not make enough progress. This makes its
worst case O(n*log(n)).</p>
<p>‘stable’ automatically choses the best stable sorting algorithm
for the data type being sorted. It is currently mapped to
merge sort.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                <span class="c1"># sort along the last axis</span>
<span class="go">array([[1, 4],</span>
<span class="go">       [1, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># sort the flattened array</span>
<span class="go">array([1, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="c1"># sort along the first axis</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<p>Use the <cite>order</cite> keyword to specify a field to use when sorting a
structured array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;S10&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Arthur&#39;</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Lancelot&#39;</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mi">38</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="s1">&#39;Galahad&#39;</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mi">38</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>       <span class="c1"># create a structured array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>                        
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="go">       (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
<p>Sort by age, then height if ages are equal:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>               
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="go">       (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ary</span></em>, <em class="sig-param"><span class="n">indices_or_sections</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.split" title="symjax.tensor.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.split" title="symjax.tensor.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sub-arrays</strong> – A list of sub-arrays.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of ndarrays</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>indices_or_sections</cite> is given as an integer, but
    a split does not result in equal division.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">array_split()</span></code></dt><dd><p>Split an array into multiple sub-arrays of equal or near-equal size.  Does not raise an exception if an equal division cannot be made.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hsplit" title="symjax.tensor.hsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">hsplit()</span></code></a></dt><dd><p>Split array into multiple sub-arrays horizontally (column-wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vsplit" title="symjax.tensor.vsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">vsplit()</span></code></a></dt><dd><p>Split array into multiple sub-arrays vertically (row wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dsplit" title="symjax.tensor.dsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">dsplit()</span></code></a></dt><dd><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a></dt><dd><p>Stack arrays in sequence horizontally (column wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a></dt><dd><p>Stack arrays in sequence vertically (row wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third dimension).</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[array([ 0.,  1.,  2.]), array([ 3.,  4.,  5.]), array([ 6.,  7.,  8.])]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">8.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="go">[array([ 0.,  1.,  2.]),</span>
<span class="go"> array([ 3.,  4.]),</span>
<span class="go"> array([ 5.]),</span>
<span class="go"> array([ 6.,  7.]),</span>
<span class="go"> array([], dtype=float64)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sqrt">
<code class="sig-name descname">sqrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non-negative square-root of an array, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sqrt" title="symjax.tensor.sqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sqrt" title="symjax.tensor.sqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code></a>.
Original docstring below.</p>
<p>sqrt(x, /, out=None, <a href="#id159"><span class="problematic" id="id160">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – An array of the same shape as <cite>x</cite>, containing the positive
square-root of each element in <cite>x</cite>.  If any element in <cite>x</cite> is
complex, a complex array is returned (and the square-roots of
negative reals are calculated).  If all of the elements in <cite>x</cite>
are real, so is <cite>y</cite>, with negative elements returning <code class="docutils literal notranslate"><span class="pre">nan</span></code>.
If <cite>out</cite> was provided, <cite>y</cite> is a reference to it.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">lib.scimath.sqrt()</span></code></dt><dd><p>A version which returns complex numbers when given negative reals.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p><em>sqrt</em> has–consistent with common convention–as its branch cut the
real “interval” [<cite>-inf</cite>, 0), and is continuous from above on it.
A branch cut is a curve in the complex plane across which a given
complex function fails to be continuous.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="go">array([ 1.,  2.,  3.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">J</span><span class="p">])</span>
<span class="go">array([ 2.+0.j,  0.+1.j,  1.+2.j])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="go">array([  2.,  NaN,  Inf])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.square">
<code class="sig-name descname">square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the element-wise square of the input.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.square" title="symjax.tensor.square"><code class="xref py py-func docutils literal notranslate"><span class="pre">square()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.square" title="symjax.tensor.square"><code class="xref py py-func docutils literal notranslate"><span class="pre">square()</span></code></a>.
Original docstring below.</p>
<p>square(x, /, out=None, <a href="#id161"><span class="problematic" id="id162">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – Element-wise <cite>x*x</cite>, of the same shape and dtype as <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.linalg.matrix_power()</span></code>, <a class="reference internal" href="#symjax.tensor.sqrt" title="symjax.tensor.sqrt"><code class="xref py py-func docutils literal notranslate"><span class="pre">sqrt()</span></code></a>, <a class="reference internal" href="#symjax.tensor.power" title="symjax.tensor.power"><code class="xref py py-func docutils literal notranslate"><span class="pre">power()</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">array([-1.-0.j,  1.+0.j])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove single-dimensional entries from the shape of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.squeeze" title="symjax.tensor.squeeze"><code class="xref py py-func docutils literal notranslate"><span class="pre">squeeze()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.squeeze" title="symjax.tensor.squeeze"><code class="xref py py-func docutils literal notranslate"><span class="pre">squeeze()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>squeezed</strong> – The input array, but with all or a subset of the
dimensions of length 1 removed. This is always <cite>a</cite> itself
or a view into <cite>a</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>axis</cite> is not <cite>None</cite>, and an axis being squeezed is not of length 1</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.expand_dims" title="symjax.tensor.expand_dims"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_dims()</span></code></a></dt><dd><p>The inverse operation, adding singleton dimensions</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.reshape" title="symjax.tensor.reshape"><code class="xref py py-func docutils literal notranslate"><span class="pre">reshape()</span></code></a></dt><dd><p>Insert, remove, and combine dimensions, and resize existing ones</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cannot select an axis to squeeze out which has size not equal to one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.stack">
<code class="sig-name descname">stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arrays</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#stack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Join a sequence of arrays along a new axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a>.
Original docstring below.</p>
<p>The <cite>axis</cite> parameter specifies the index of the new axis in the dimensions
of the result. For example, if <code class="docutils literal notranslate"><span class="pre">axis=0</span></code> it will be the first dimension
and if <code class="docutils literal notranslate"><span class="pre">axis=-1</span></code> it will be the last dimension.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.0.</span></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>stacked</strong> – The stacked array has one more dimension than the input arrays.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.split" title="symjax.tensor.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a></dt><dd><p>Split array into a list of multiple sub-arrays of equal size.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.block" title="symjax.tensor.block"><code class="xref py py-func docutils literal notranslate"><span class="pre">block()</span></code></a></dt><dd><p>Assemble arrays from blocks.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(10, 3, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 10, 4)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 4, 10)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#std"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation along the specified axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.std" title="symjax.tensor.std"><code class="xref py py-func docutils literal notranslate"><span class="pre">std()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.std" title="symjax.tensor.std"><code class="xref py py-func docutils literal notranslate"><span class="pre">std()</span></code></a>.
Original docstring below.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution,
of the array elements. The standard deviation is computed for the
flattened array by default, otherwise over the specified axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Type to use in computing the standard deviation. For arrays of
integer type the default is float64, for arrays of float types it is
the same as the array type.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>standard_deviation</strong> – If <cite>out</cite> is None, return a new array containing the standard deviation,
otherwise return a reference to the output array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, see dtype parameter above.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.var" title="symjax.tensor.var"><code class="xref py py-func docutils literal notranslate"><span class="pre">var()</span></code></a>, <a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanmean()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanstd()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanvar()</span></code></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The standard deviation is the square root of the average of the squared
deviations from the mean, i.e., <code class="docutils literal notranslate"><span class="pre">std</span> <span class="pre">=</span> <span class="pre">sqrt(mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2))</span></code>.</p>
<p>The average squared deviation is normally calculated as
<code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.  If, however, <cite>ddof</cite> is specified,
the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used instead. In standard statistical
practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an unbiased estimator of the variance
of the infinite population. <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood
estimate of the variance for normally distributed variables. The
standard deviation computed in this function is the square root of
the estimated variance, so even with <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code>, it will not be an
unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <cite>std</cite> takes the absolute
value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example below).
Specifying a higher-accuracy accumulator using the <cite>dtype</cite> keyword can
alleviate this issue.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.1180339887498949</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.5,  0.5])</span>
</pre></div>
</div>
<p>In single precision, std() can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.45000005</span>
</pre></div>
</div>
<p>Computing the standard deviation in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.44999999925494177</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.subtract">
<code class="sig-name descname">subtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract arguments, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.subtract" title="symjax.tensor.subtract"><code class="xref py py-func docutils literal notranslate"><span class="pre">subtract()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.subtract" title="symjax.tensor.subtract"><code class="xref py py-func docutils literal notranslate"><span class="pre">subtract()</span></code></a>.
Original docstring below.</p>
<p>subtract(x1, x2, /, out=None, <a href="#id163"><span class="problematic" id="id164">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The difference of <cite>x1</cite> and <cite>x2</cite>, element-wise.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">-</span> <span class="pre">x2</span></code> in terms of array broadcasting.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="go">-3.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">9.0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">3.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 3.,  3.,  3.],</span>
<span class="go">       [ 6.,  6.,  6.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of array elements over a given axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sum" title="symjax.tensor.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.sum" title="symjax.tensor.sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – The type of the returned array and of the accumulator in which the
elements are summed.  The dtype of <cite>a</cite> is used by default unless <cite>a</cite>
has an integer dtype of less precision than the default platform
integer.  In that case, if <cite>a</cite> is signed then the platform integer
is used while if <cite>a</cite> is unsigned then an unsigned integer of the
same precision as the platform integer is used.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sum_along_axis</strong> – An array with the same shape as <cite>a</cite>, with the specified
axis removed.   If <cite>a</cite> is a 0-d array, or if <cite>axis</cite> is None, a scalar
is returned.  If an output array is specified, a reference to
<cite>out</cite> is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.sum()</span></code></dt><dd><p>Equivalent method.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.cumsum" title="symjax.tensor.cumsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">cumsum()</span></code></a></dt><dd><p>Cumulative sum of array elements.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">trapz()</span></code></dt><dd><p>Integration of array values using the composite trapezoidal rule.</p>
</dd>
</dl>
<p><a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">average()</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Arithmetic is modular when using integer types, and no error is
raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([])</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([1, 5])</span>
</pre></div>
</div>
<p>If the accumulator is too small, overflow occurs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">-128</span>
</pre></div>
</div>
<p>You can also start the sum with a value other than zero:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.swapaxes">
<code class="sig-name descname">swapaxes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis1</span></em>, <em class="sig-param"><span class="n">axis2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchange two axes of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.swapaxes" title="symjax.tensor.swapaxes"><code class="xref py py-func docutils literal notranslate"><span class="pre">swapaxes()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.swapaxes" title="symjax.tensor.swapaxes"><code class="xref py py-func docutils literal notranslate"><span class="pre">swapaxes()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>a_swapped</strong> – For NumPy &gt;= 1.10.0, if <cite>a</cite> is an ndarray, then a view of <cite>a</cite> is
returned; otherwise a new array is created. For earlier NumPy
versions a view of <cite>a</cite> is returned only if the order of the
axes is changed, otherwise the input array is returned.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[[0, 1],</span>
<span class="go">        [2, 3]],</span>
<span class="go">       [[4, 5],</span>
<span class="go">        [6, 7]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[[0, 4],</span>
<span class="go">        [2, 6]],</span>
<span class="go">       [[1, 5],</span>
<span class="go">        [3, 7]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#take"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take elements from an array along an axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.take" title="symjax.tensor.take"><code class="xref py py-func docutils literal notranslate"><span class="pre">take()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.take" title="symjax.tensor.take"><code class="xref py py-func docutils literal notranslate"><span class="pre">take()</span></code></a>.
Original docstring below.</p>
<p>When axis is not None, this function does the same thing as “fancy”
indexing (indexing arrays using arrays); however, it can be easier to use
if you need elements along a given axis. A call such as
<code class="docutils literal notranslate"><span class="pre">np.take(arr,</span> <span class="pre">indices,</span> <span class="pre">axis=3)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">arr[:,:,:,indices,...]</span></code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use
of <cite>ndindex</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code>, <code class="docutils literal notranslate"><span class="pre">jj</span></code>, and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of
indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">Nj</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">jj</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">jj</span><span class="p">],)</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – The returned array has the same type as <cite>a</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray (Ni…, Nj…, Nk…)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">compress()</span></code></dt><dd><p>Take elements using a boolean mask</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">ndarray.take()</span></code></dt><dd><p>equivalent method</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.take_along_axis" title="symjax.tensor.take_along_axis"><code class="xref py py-func docutils literal notranslate"><span class="pre">take_along_axis()</span></code></a></dt><dd><p>Take elements by matching the array and the index arrays</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>By eliminating the inner loop in the description above, and using <cite>s_</cite> to
build simple slice objects, <cite>take</cite> can be expressed  in terms of applying
fancy indexing to each 1-d slice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nj</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[</span><span class="o">...</span><span class="p">,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
</pre></div>
</div>
<p>For this reason, it is equivalent to (but faster than) the following use
of <cite>apply_along_axis</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a_1d</span><span class="p">:</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>In this example if <cite>a</cite> is an ndarray, “fancy” indexing can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
<span class="go">array([4, 3, 6])</span>
</pre></div>
</div>
<p>If <cite>indices</cite> is not one dimensional, the output also has these dimensions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="go">array([[4, 3],</span>
<span class="go">       [5, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.take_along_axis">
<code class="sig-name descname">take_along_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arr</span></em>, <em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">axis</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#take_along_axis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.take_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Take values from the input array by matching 1d index and data slices.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.take_along_axis" title="symjax.tensor.take_along_axis"><code class="xref py py-func docutils literal notranslate"><span class="pre">take_along_axis()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.take_along_axis" title="symjax.tensor.take_along_axis"><code class="xref py py-func docutils literal notranslate"><span class="pre">take_along_axis()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div><p>This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to look up values in the
latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <cite>argsort</cite> and
<cite>argpartition</cite>, produce suitable indices for this function.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.15.0.</span></p>
</div>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>out: ndarray (Ni…, J, Nk…)</dt><dd><p>The indexed result.</p>
</dd>
</dl>
<p>This is equivalent to (but faster than) the following use of <cite>ndindex</cite> and
<cite>s_</cite>, which sets each of <code class="docutils literal notranslate"><span class="pre">ii</span></code> and <code class="docutils literal notranslate"><span class="pre">kk</span></code> to a tuple of indices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ni</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Nk</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>  <span class="c1"># Need not equal M</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Nk</span> <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="p">,)</span> <span class="o">+</span> <span class="n">Nk</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Ni</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">ndindex</span><span class="p">(</span><span class="n">Nk</span><span class="p">):</span>
        <span class="n">a_1d</span>       <span class="o">=</span> <span class="n">a</span>      <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">indices_1d</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="n">out_1d</span>     <span class="o">=</span> <span class="n">out</span>    <span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="n">s_</span><span class="p">[:,]</span> <span class="o">+</span> <span class="n">kk</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">J</span><span class="p">):</span>
            <span class="n">out_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
</pre></div>
</div>
<p>Equivalently, eliminating the inner loop, the last two lines would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out_1d</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a_1d</span><span class="p">[</span><span class="n">indices_1d</span><span class="p">]</span>
</pre></div>
</div>
<p>take : Take along an axis, using the same indices for every 1d slice
put_along_axis :</p>
<blockquote>
<div><p>Put values into the destination array by matching 1d index and data slices</p>
</div></blockquote>
<p>For this sample array</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]])</span>
</pre></div>
</div>
<p>We can sort either by using sort directly, or argsort and this function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 20, 30],</span>
<span class="go">       [40, 50, 60]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span> <span class="n">ai</span>
<span class="go">array([[0, 2, 1],</span>
<span class="go">       [1, 2, 0]], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 20, 30],</span>
<span class="go">       [40, 50, 60]])</span>
</pre></div>
</div>
<p>The same works for max and min, if you expand the dimensions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[30],</span>
<span class="go">       [60]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span>
<span class="go">array([[1],</span>
<span class="go">       [0], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[30],</span>
<span class="go">       [60]])</span>
</pre></div>
</div>
<p>If we want to get the max and min at the same time, we can stack the
indices first</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ai_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ai_min</span><span class="p">,</span> <span class="n">ai_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
<span class="go">&gt;&gt; ai</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0]], dtype=int64)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[10, 30],</span>
<span class="go">       [40, 60]])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tan">
<code class="sig-name descname">tan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tangent element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tan" title="symjax.tensor.tan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tan()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tan" title="symjax.tensor.tan"><code class="xref py py-func docutils literal notranslate"><span class="pre">tan()</span></code></a>.
Original docstring below.</p>
<p>tan(x, /, out=None, <a href="#id165"><span class="problematic" id="id166">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.sin(x)/np.cos(x)</span></code> element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding tangent values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">pi</span><span class="p">]))</span>
<span class="go">array([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter illustrating</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># that what is returned is a reference to said parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">invalid return array shape</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tanh">
<code class="sig-name descname">tanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hyperbolic tangent element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tanh" title="symjax.tensor.tanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tanh()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tanh" title="symjax.tensor.tanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tanh()</span></code></a>.
Original docstring below.</p>
<p>tanh(x, /, out=None, <a href="#id167"><span class="problematic" id="id168">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">np.sinh(x)/np.cosh(x)</span></code> or <code class="docutils literal notranslate"><span class="pre">-1j</span> <span class="pre">*</span> <span class="pre">np.tan(1j*x)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>y</strong> – The corresponding hyperbolic tangent values.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <cite>out</cite> is provided, the function writes the result into it,
and returns a reference to <cite>out</cite>.  (See Examples)</p>
<p class="rubric">References</p>
<dl class="footnote brackets">
<dt class="label" id="id169"><span class="brackets">1</span></dt>
<dd><p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
New York, NY: Dover, 1972, pg. 83.
<a class="reference external" href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
</dd>
<dt class="label" id="id170"><span class="brackets">2</span></dt>
<dd><p>Wikipedia, “Hyperbolic function”,
<a class="reference external" href="http://en.wikipedia.org/wiki/Hyperbolic_function">http://en.wikipedia.org/wiki/Hyperbolic_function</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="go">array([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of providing the optional output parameter illustrating</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># that what is returned is a reference to said parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">([</span><span class="mf">0.1</span><span class="p">],</span> <span class="n">out1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out2</span> <span class="ow">is</span> <span class="n">out1</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of ValueError due to provision of shape mis-matched `out`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">invalid return array shape</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tensordot">
<code class="sig-name descname">tensordot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">precision</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#tensordot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tensor dot product along specified axes for arrays &gt;= 1-D.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tensordot" title="symjax.tensor.tensordot"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensordot()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tensordot" title="symjax.tensor.tensordot"><code class="xref py py-func docutils literal notranslate"><span class="pre">tensordot()</span></code></a>.
In addition to the original NumPy arguments listed below, also supports
<code class="docutils literal notranslate"><span class="pre">precision</span></code> for extra control over matrix-multiplication precision
on supported devices. See <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.lax.dot()</span></code> for details.</p>
<p>Original docstring below.</p>
<p>Given two tensors (arrays of dimension greater than or equal to one),
<cite>a</cite> and <cite>b</cite>, and an array_like object containing two array_like
objects, <code class="docutils literal notranslate"><span class="pre">(a_axes,</span> <span class="pre">b_axes)</span></code>, sum the products of <cite>a</cite>’s and <cite>b</cite>’s
elements (components) over the axes specified by <code class="docutils literal notranslate"><span class="pre">a_axes</span></code> and
<code class="docutils literal notranslate"><span class="pre">b_axes</span></code>. The third argument can be a single non-negative
integer_like scalar, <code class="docutils literal notranslate"><span class="pre">N</span></code>; if it is such, then the last <code class="docutils literal notranslate"><span class="pre">N</span></code>
dimensions of <cite>a</cite> and the first <code class="docutils literal notranslate"><span class="pre">N</span></code> dimensions of <cite>b</cite> are summed
over.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>)</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tile">
<code class="sig-name descname">tile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">reps</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#tile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an array by repeating A the number of times given by reps.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tile" title="symjax.tensor.tile"><code class="xref py py-func docutils literal notranslate"><span class="pre">tile()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tile" title="symjax.tensor.tile"><code class="xref py py-func docutils literal notranslate"><span class="pre">tile()</span></code></a>.
Original docstring below.</p>
<p>If <cite>reps</cite> has length <code class="docutils literal notranslate"><span class="pre">d</span></code>, the result will have dimension of
<code class="docutils literal notranslate"><span class="pre">max(d,</span> <span class="pre">A.ndim)</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A.ndim</span> <span class="pre">&lt;</span> <span class="pre">d</span></code>, <cite>A</cite> is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote <cite>A</cite> to d-dimensions manually before calling this
function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">A.ndim</span> <span class="pre">&gt;</span> <span class="pre">d</span></code>, <cite>reps</cite> is promoted to <cite>A</cite>.ndim by pre-pending 1’s to it.
Thus for an <cite>A</cite> of shape (2, 3, 4, 5), a <cite>reps</cite> of (2, 2) is treated as
(1, 1, 2, 2).</p>
<p>Note : Although tile may be used for broadcasting, it is strongly
recommended to use numpy’s broadcasting operations and functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>c</strong> – The tiled output array.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.repeat" title="symjax.tensor.repeat"><code class="xref py py-func docutils literal notranslate"><span class="pre">repeat()</span></code></a></dt><dd><p>Repeat elements of an array.</p>
</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">broadcast_to()</span></code></dt><dd><p>Broadcast an array to a new shape</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([0, 1, 2, 0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[0, 1, 2, 0, 1, 2],</span>
<span class="go">       [0, 1, 2, 0, 1, 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">array([[[0, 1, 2, 0, 1, 2]],</span>
<span class="go">       [[0, 1, 2, 0, 1, 2]]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[1, 2, 1, 2],</span>
<span class="go">       [3, 4, 3, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">c</span><span class="p">,(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4],</span>
<span class="go">       [1, 2, 3, 4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.trace">
<code class="sig-name descname">trace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">offset</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">axis1</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">axis2</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#trace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum along diagonals of the array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.trace" title="symjax.tensor.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">trace()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.trace" title="symjax.tensor.trace"><code class="xref py py-func docutils literal notranslate"><span class="pre">trace()</span></code></a>.
Original docstring below.</p>
<p>If <cite>a</cite> is 2-D, the sum along its diagonal with the given offset
is returned, i.e., the sum of elements <code class="docutils literal notranslate"><span class="pre">a[i,i+offset]</span></code> for all i.</p>
<p>If <cite>a</cite> has more than two dimensions, then the axes specified by axis1 and
axis2 are used to determine the 2-D sub-arrays whose traces are returned.
The shape of the resulting array is the same as that of <cite>a</cite> with <cite>axis1</cite>
and <cite>axis2</cite> removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Determines the data-type of the returned array and of the accumulator
where the elements are summed. If dtype has the value None and <cite>a</cite> is
of integer type of precision less than the default integer
precision, then the default integer precision is used. Otherwise,
the precision is the same as that of <cite>a</cite>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sum_along_diagonals</strong> – If <cite>a</cite> is 2-D, the sum along the diagonal is returned.  If <cite>a</cite> has
larger dimensions, then an array of sums along diagonals is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.diag" title="symjax.tensor.diag"><code class="xref py py-func docutils literal notranslate"><span class="pre">diag()</span></code></a>, <a class="reference internal" href="#symjax.tensor.diagonal" title="symjax.tensor.diagonal"><code class="xref py py-func docutils literal notranslate"><span class="pre">diagonal()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">diagflat()</span></code></p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([6, 8])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute the dimensions of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.transpose" title="symjax.tensor.transpose"><code class="xref py py-func docutils literal notranslate"><span class="pre">transpose()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.transpose" title="symjax.tensor.transpose"><code class="xref py py-func docutils literal notranslate"><span class="pre">transpose()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>p</strong> – <cite>a</cite> with its axes permuted.  A view is returned whenever
possible.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.moveaxis" title="symjax.tensor.moveaxis"><code class="xref py py-func docutils literal notranslate"><span class="pre">moveaxis()</span></code></a>, <a class="reference internal" href="#symjax.tensor.argsort" title="symjax.tensor.argsort"><code class="xref py py-func docutils literal notranslate"><span class="pre">argsort()</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Use <cite>transpose(a, argsort(axes))</cite> to invert the transposition of tensors
when using the <cite>axes</cite> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [2, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 2],</span>
<span class="go">       [1, 3]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 1, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tri">
<code class="sig-name descname">tri</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">N</span></em>, <em class="sig-param"><span class="n">M</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#tri"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.tri" title="Permalink to this definition">¶</a></dt>
<dd><p>An array with ones at and below the given diagonal and zeros elsewhere.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tri" title="symjax.tensor.tri"><code class="xref py py-func docutils literal notranslate"><span class="pre">tri()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tri" title="symjax.tensor.tri"><code class="xref py py-func docutils literal notranslate"><span class="pre">tri()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>dtype</em><em>, </em><em>optional</em>) – Data type of the returned array.  The default is float.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tri</strong> – Array with its lower triangle filled with ones and zero elsewhere;
in other words <code class="docutils literal notranslate"><span class="pre">T[i,j]</span> <span class="pre">==</span> <span class="pre">1</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">j</span> <span class="pre">+</span> <span class="pre">k</span></code>, 0 otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray of shape (N, M)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 0],</span>
<span class="go">       [1, 1, 1, 1, 1]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 1.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 1.,  1.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tril">
<code class="sig-name descname">tril</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#tril"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.tril" title="Permalink to this definition">¶</a></dt>
<dd><p>Lower triangle of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tril" title="symjax.tensor.tril"><code class="xref py py-func docutils literal notranslate"><span class="pre">tril()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tril" title="symjax.tensor.tril"><code class="xref py py-func docutils literal notranslate"><span class="pre">tril()</span></code></a>.
Original docstring below.</p>
<p>Return a copy of an array with elements above the <cite>k</cite>-th diagonal zeroed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>tril</strong> – Lower triangle of <cite>m</cite>, of same shape and data-type as <cite>m</cite>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray, shape (M, N)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.triu" title="symjax.tensor.triu"><code class="xref py py-func docutils literal notranslate"><span class="pre">triu()</span></code></a></dt><dd><p>same thing, only for the upper triangle</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[ 0,  0,  0],</span>
<span class="go">       [ 4,  0,  0],</span>
<span class="go">       [ 7,  8,  0],</span>
<span class="go">       [10, 11, 12]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.tril_indices">
<code class="sig-name descname">tril_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.tril_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the lower-triangle of an (n, m) array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tril_indices" title="symjax.tensor.tril_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">tril_indices()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.tril_indices" title="symjax.tensor.tril_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">tril_indices()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>inds<span class="classifier">tuple of arrays</span></dt><dd><p>The indices for the triangle. The returned tuple contains two arrays,
each with the indices along one dimension of the array.</p>
</dd>
</dl>
<p>triu_indices : similar function, for upper-triangular.
mask_indices : generic function accepting an arbitrary mask function.
tril, triu</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>Compute two different sets of indices to access 4x4 arrays, one for the
lower triangular part starting at the main diagonal, and one starting two
diagonals further right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">il1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is how they can be used with a sample array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Both for indexing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il1</span><span class="p">]</span>
<span class="go">array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])</span>
</pre></div>
</div>
<p>And for assigning values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1,  1,  2,  3],</span>
<span class="go">       [-1, -1,  6,  7],</span>
<span class="go">       [-1, -1, -1, 11],</span>
<span class="go">       [-1, -1, -1, -1]])</span>
</pre></div>
</div>
<p>These cover almost the whole array (two diagonals right of the main one):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">il2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-10, -10, -10,   3],</span>
<span class="go">       [-10, -10, -10, -10],</span>
<span class="go">       [-10, -10, -10, -10],</span>
<span class="go">       [-10, -10, -10, -10]])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.triu">
<code class="sig-name descname">triu</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#triu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.triu" title="Permalink to this definition">¶</a></dt>
<dd><p>Upper triangle of an array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.triu" title="symjax.tensor.triu"><code class="xref py py-func docutils literal notranslate"><span class="pre">triu()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LA</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.triu_indices">
<code class="sig-name descname">triu_indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.triu_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices for the upper-triangle of an (n, m) array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.triu_indices" title="symjax.tensor.triu_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">triu_indices()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.triu_indices" title="symjax.tensor.triu_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">triu_indices()</span></code></a>.
Original docstring below.</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl>
<dt>inds<span class="classifier">tuple, shape(2) of ndarrays, shape(<cite>n</cite>)</span></dt><dd><p>The indices for the triangle. The returned tuple contains two arrays,
each with the indices along one dimension of the array.  Can be used
to slice a ndarray of shape(<cite>n</cite>, <cite>n</cite>).</p>
</dd>
</dl>
<p>tril_indices : similar function, for lower-triangular.
mask_indices : generic function accepting an arbitrary mask function.
triu, tril</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.4.0.</span></p>
</div>
<p>Compute two different sets of indices to access 4x4 arrays, one for the
upper triangular part starting at the main diagonal, and one starting two
diagonals further right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iu1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iu2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is how they can be used with a sample array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
</pre></div>
</div>
<p>Both for indexing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span>
<span class="go">array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])</span>
</pre></div>
</div>
<p>And for assigning values:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[-1, -1, -1, -1],</span>
<span class="go">       [ 4, -1, -1, -1],</span>
<span class="go">       [ 8,  9, -1, -1],</span>
<span class="go">       [12, 13, 14, -1]])</span>
</pre></div>
</div>
<p>These cover only a small part of the whole array (two diagonals right
of the main one):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">iu2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ -1,  -1, -10, -10],</span>
<span class="go">       [  4,  -1,  -1, -10],</span>
<span class="go">       [  8,   9,  -1,  -1],</span>
<span class="go">       [ 12,  13,  14,  -1]])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.true_divide">
<code class="sig-name descname">true_divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#true_divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.true_divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a true division of the inputs, element-wise.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.true_divide" title="symjax.tensor.true_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">true_divide()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.true_divide" title="symjax.tensor.true_divide"><code class="xref py py-func docutils literal notranslate"><span class="pre">true_divide()</span></code></a>.
Original docstring below.</p>
<p>true_divide(x1, x2, /, out=None, <a href="#id171"><span class="problematic" id="id172">*</span></a>, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p>
<p>Instead of the Python traditional ‘floor division’, this returns a true
division.  True division adjusts the output type to present the best
answer, regardless of input types.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> – This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray or scalar</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The floor division operator <code class="docutils literal notranslate"><span class="pre">//</span></code> was added in Python 2.2 making
<code class="docutils literal notranslate"><span class="pre">//</span></code> and <code class="docutils literal notranslate"><span class="pre">/</span></code> equivalent operators.  The default floor division
operation of <code class="docutils literal notranslate"><span class="pre">/</span></code> can be replaced by true division with <code class="docutils literal notranslate"><span class="pre">from</span>
<span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">division</span></code>.</p>
<p>In Python 3.0, <code class="docutils literal notranslate"><span class="pre">//</span></code> is the floor division operator and <code class="docutils literal notranslate"><span class="pre">/</span></code> the
true division operator.  The <code class="docutils literal notranslate"><span class="pre">true_divide(x1,</span> <span class="pre">x2)</span></code> function is
equivalent to true division in Python.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">/</span><span class="mi">4</span>
<span class="go">array([0, 0, 0, 0, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">//</span><span class="mi">4</span>
<span class="go">array([0, 0, 0, 0, 1])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">/</span><span class="mi">4</span>
<span class="go">array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">//</span><span class="mi">4</span>
<span class="go">array([0, 0, 0, 0, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#var"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance along the specified axis.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.var" title="symjax.tensor.var"><code class="xref py py-func docutils literal notranslate"><span class="pre">var()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.var" title="symjax.tensor.var"><code class="xref py py-func docutils literal notranslate"><span class="pre">var()</span></code></a>.
Original docstring below.</p>
<p>Returns the variance of the array elements, a measure of the spread of a
distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Type to use in computing the variance.  For arrays of integer type
the default is <cite>float32</cite>; for arrays of float types it is the same as
the array type.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>variance</strong> – If <code class="docutils literal notranslate"><span class="pre">out=None</span></code>, returns a new array containing the variance;
otherwise, a reference to the output array is returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray, see dtype parameter above</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#symjax.tensor.std" title="symjax.tensor.std"><code class="xref py py-func docutils literal notranslate"><span class="pre">std()</span></code></a>, <a class="reference internal" href="#symjax.tensor.mean" title="symjax.tensor.mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">mean()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanmean()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanstd()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">nanvar()</span></code></p>
<dl class="simple">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.doc.ufuncs()</span></code></dt><dd><p>Section “Output arguments”</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The variance is the average of the squared deviations from the mean,
i.e.,  <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">mean(abs(x</span> <span class="pre">-</span> <span class="pre">x.mean())**2)</span></code>.</p>
<p>The mean is normally calculated as <code class="docutils literal notranslate"><span class="pre">x.sum()</span> <span class="pre">/</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">len(x)</span></code>.
If, however, <cite>ddof</cite> is specified, the divisor <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">ddof</span></code> is used
instead.  In standard statistical practice, <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> provides an
unbiased estimator of the variance of a hypothetical infinite population.
<code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> provides a maximum likelihood estimate of the variance for
normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for <cite>float32</cite> (see example
below).  Specifying a higher-accuracy accumulator using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>
keyword can alleviate this issue.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">1.25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 1.,  1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([ 0.25,  0.25])</span>
</pre></div>
</div>
<p>In single precision, var() can be inaccurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">512</span><span class="o">*</span><span class="mi">512</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0.20250003</span>
</pre></div>
</div>
<p>Computing the variance in float64 is more accurate:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="go">0.20249999932944759</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.1</span><span class="o">-</span><span class="mf">0.55</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="go">0.2025</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.vdot">
<code class="sig-name descname">vdot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">precision</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#vdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.vdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dot product of two vectors.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vdot" title="symjax.tensor.vdot"><code class="xref py py-func docutils literal notranslate"><span class="pre">vdot()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vdot" title="symjax.tensor.vdot"><code class="xref py py-func docutils literal notranslate"><span class="pre">vdot()</span></code></a>.
In addition to the original NumPy arguments listed below, also supports
<code class="docutils literal notranslate"><span class="pre">precision</span></code> for extra control over matrix-multiplication precision
on supported devices. See <code class="xref py py-func docutils literal notranslate"><span class="pre">jax.lax.dot()</span></code> for details.</p>
<p>Original docstring below.</p>
<p>vdot(a, b)</p>
<blockquote>
<div><blockquote>
<div><p>The vdot(<cite>a</cite>, <cite>b</cite>) function handles complex numbers differently than
dot(<cite>a</cite>, <cite>b</cite>).  If the first argument is complex the complex conjugate
of the first argument is used for the calculation of the dot product.</p>
<p>Note that <cite>vdot</cite> handles multidimensional arrays differently than <cite>dot</cite>:
it does <em>not</em> perform a matrix product, but flattens input arguments
to 1-D vectors first. Consequently, it should only be used for vectors.</p>
</div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>Dot product of <cite>a</cite> and <cite>b</cite>.  Can be an int, float, or
complex depending on the types of <cite>a</cite> and <cite>b</cite>.</p>
</dd>
</dl>
<dl class="simple">
<dt>dot<span class="classifier">Return the dot product without using the complex conjugate of the</span></dt><dd><p>first argument.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">,</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">(70-8j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">(70+8j)</span>
</pre></div>
</div>
<p>Note that higher-dimensional arrays are flattened!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="mi">2</span>
<span class="go">30</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.vsplit">
<code class="sig-name descname">vsplit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ary</span></em>, <em class="sig-param"><span class="n">indices_or_sections</span></em><span class="sig-paren">)</span><a class="headerlink" href="#symjax.tensor.vsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split an array into multiple sub-arrays vertically (row-wise).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vsplit" title="symjax.tensor.vsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">vsplit()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LA</p>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.vstack">
<code class="sig-name descname">vstack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tup</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#vstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.vstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack arrays in sequence vertically (row wise).</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.vstack" title="symjax.tensor.vstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">vstack()</span></code></a>.
Original docstring below.</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays
of shape <cite>(N,)</cite> have been reshaped to <cite>(1,N)</cite>. Rebuilds arrays divided by
<cite>vsplit</cite>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions <cite>concatenate</cite>, <cite>stack</cite> and
<cite>block</cite> provide more general stacking and concatenation operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>stacked</strong> – The array formed by stacking the given arrays, will be at least 2-D.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.stack" title="symjax.tensor.stack"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack()</span></code></a></dt><dd><p>Join a sequence of arrays along a new axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.hstack" title="symjax.tensor.hstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">hstack()</span></code></a></dt><dd><p>Stack arrays in sequence horizontally (column wise).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.dstack" title="symjax.tensor.dstack"><code class="xref py py-func docutils literal notranslate"><span class="pre">dstack()</span></code></a></dt><dd><p>Stack arrays in sequence depth wise (along third dimension).</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.concatenate" title="symjax.tensor.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate()</span></code></a></dt><dd><p>Join a sequence of arrays along an existing axis.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.vsplit" title="symjax.tensor.vsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">vsplit()</span></code></a></dt><dd><p>Split array into a list of multiple sub-arrays vertically.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.block" title="symjax.tensor.block"><code class="xref py py-func docutils literal notranslate"><span class="pre">block()</span></code></a></dt><dd><p>Assemble arrays from blocks.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [2, 3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="go">array([[1],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [2],</span>
<span class="go">       [3],</span>
<span class="go">       [4]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.zeros">
<code class="sig-name descname">zeros</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with zeros.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a>.
Original docstring below.</p>
<p>zeros(shape, dtype=float, order=’C’)</p>
<blockquote>
<div><blockquote>
<div></div></blockquote>
<dl>
<dt>Returns</dt><dd><dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="go">array([(0, 0), (0, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="symjax.tensor.zeros_like">
<code class="sig-name descname">zeros_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/jax/numpy/lax_numpy.html#zeros_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#symjax.tensor.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type as a given array.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros_like" title="symjax.tensor.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a>.
ADDITIONOriginal docstring below.</p>
<p>LAX-backend implementation of <a class="reference internal" href="#symjax.tensor.zeros_like" title="symjax.tensor.zeros_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros_like()</span></code></a>.
Original docstring below.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dtype</strong> (<em>data-type</em><em>, </em><em>optional</em>) – Overrides the data type of the result.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> – Array of zeros with the same shape and type as <cite>a</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#symjax.tensor.empty_like" title="symjax.tensor.empty_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">empty_like()</span></code></a></dt><dd><p>Return an empty array with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.ones_like" title="symjax.tensor.ones_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">ones_like()</span></code></a></dt><dd><p>Return an array of ones with shape and type of input.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.full_like" title="symjax.tensor.full_like"><code class="xref py py-func docutils literal notranslate"><span class="pre">full_like()</span></code></a></dt><dd><p>Return a new array with shape of input filled with value.</p>
</dd>
<dt><a class="reference internal" href="#symjax.tensor.zeros" title="symjax.tensor.zeros"><code class="xref py py-func docutils literal notranslate"><span class="pre">zeros()</span></code></a></dt><dd><p>Return a new array setting values to zero.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [3, 4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pdfs.html" class="btn btn-neutral float-right" title="symjax.tensor.pdfs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="symjax.html" class="btn btn-neutral float-left" title="symjax" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Randall Balestriero

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>